[{"title":"深入分析classloader","date":"2017-02-06T12:48:24.000Z","path":"2017/02/06/classloader/","text":"classloader我相信大家都很明白能做什么事情，不能做什么事情，能做的事情从字面意思，我们很容易知道是类加载器,其实classloader这个单词就很通俗的说明了是class加载器，不能加载其它，可能有能有疑问，不是可以加载资源和so吗？确实没错，classloader是代码，资源大管家，注意这里的资源不是android里面的assetsmanager，比如加载文件，最为常见的是加载配置文件，属性文件，写后台的很常见，我们写客户端的基本很少用到，既然classloader能做这么多事情，那么问题来了，我们在android代码的时候根本没有用到了，class也加载进来了，对象也创建出来了，这是什么原因了。是的，我们想想，如果我们平时开发每创建一个对象都要手动classloader加载，肯定是很繁琐的。这个流程系统接管了，所以导致很多同学对class的加载流程不是很明白，即使在网上看了一些文档，也没有根本理解原理。那么这篇文章我就跟同学们较为全面，深入的讲解，让我们能真正的理解的classloader的加载机制，命名空间，隔离行等特性。 正确使用classloader需要明白的问题 classloader的加载机制(双亲委派) classloader类型 classloader命名空间 classloader隔离机制 classloader下的class缓存 打破classloader正常委派机制 java classloader与android classloader的异同 classloader的运用场景 classloader常见问题以及解决方法 下面就按照上面的大纲详细的讲解每一个节点，尽可能的讲解到每个细节，真正的理解classloader的本质，以后遇到只要关于的classloader问题以及关联的问题，能想到解决方案就好, 废话不多说，还是希望同学们，好好学习classloader，重要性不言而喻。 classloader的加载机制(双亲委派)这个我相信很多同学都知道这个机制，或多或少在网上也看了一些资料，面试的时候肯定也会问到，只要一些深入点的面试，那么双亲委派到底是什么玩意了，我们带着这些疑问展开，为什么是双亲，为什么不是单亲，为什么是委派，为什么不是代理。这样我们就能够去深入挖掘这些疑点了，首先看双亲，这个其实很好理解，也就是我们一般定义一个类加载器都有两个父亲，最为常见的java下有ExtensionClassloader,BootClassloder,android下PathClassloder,BootClassloder,注意这里两个父亲不是平行的，也就是延用了java的单继承模式，是单继承的，只是链接起来了，就好比一个链表，这样理解对于后面打破正常双亲模式很有用处，比如as的instat run代码加载就是这种方式。这样有什么好处了，首先从安全性考虑，系统类，我们是没法覆盖的，比如java.lang.String 这个类，我们是没办法覆盖的，因为我们根本没机会去加载它，但是也带了不好的方面，如果这个类在发布之后，发现了bug，那么我们只能等下一个版本修复，我们自己的类就不一样，我们自己的类自己的加载器加载，如果出现bug，可以通过替换class的方式实现热修复，这也是热修复类修复的一种方式。这样设计很好的保证了了系统代码的安全，不被一些恶意代码攻击，从而保证系统的相对的稳定性，前提是我们的代码是健康的。 classloader类型之所以有不同类型的classloader，是为了更好的区分classloader的职责，也就是oop里面的单一职责原则，这样能够更清晰的体现出classloader的模型，也能更好的维护，扩展等好处，比如java里面ext就是ExtensionClassloder负责加载，rt就是BootClassloader负责加载，我们自己定义的class就是系统SystemClassloder加载，android里面默认情况下就是PathClassloader负责加载dex里面的class。只有对这些类加载器负责加载的class，我们才知道，什么类最适合什么类加载器进行加载 classloader命名空间这个命名空间就好比给每个加载进来的class打上了一个前缀，注意这个跟pre verify class flag是不一样的，不要混淆了，这个就是xml术语里面的namespace，为了区分不同类加载加载的类，那么是什么意思了，有什么用途了，为什么要这么做了，我们带着这些疑问，来一步步分析，首先namespace的意思在不同语境下含义是不一样的，但是大多数场景下都是解决冲突，c++,android xml,等都可以看到它的身影，确实很用用，只是我们平时很少去关注它，那么在classloader的语境下就是为了区分不同的class来自不同的classloader，用途就是避免来自不同的classloader的class进行互操作，这样做的目的还是保证class的唯一性。明白了这个特性我们就在写插件的时候要特别注意，我们知道java是不支持多继承的，但是我们可以用多接口来实现多继承，那么问题来了，有时接口的很多端要使用的，我们会讲接口单独成jar包，我们在打包的时候，就一定要小心，不要将这个jar包一起包含进去，android里面最为常见就是直接provider就好。 classloader隔离机制说到隔离，我相信同学们都明白，不管是java的运行，还是android的apk运行，都是运行在沙箱里面的，也就是进程之间是隔离的。默认情况下进程之间是不同进行数据交互的，也不能尽兴行为通信的，那么classloader在不同进程之间也是隔离的，不同进程之间的classloader对象不一样，类的命名空间必然就不一样了，这里在开发插件的时候可能会用到这个技术，让一些类在其他进程的classloader里面去加载，这样做的好处有，比如安全隔离，内存分担等。 classloader下的class缓存假如同学们看过classloader的源码，不管是java，还是android的，只要基于jvm的classloader，大家应该都看到过代码，loadclass这个方法并不是直接委派给parent去加载，而是首先从缓存取，如果取到了，直接return了，如果取不到再交给parent，这样做的好处是加快响应速度，坏处就是一但这个类被加载了，我们是没办法卸载的，这个就是很多基于class热修复的框架必须重启app生效的根本原因。我们只有知道了这些原因，我们遇到问题才能很好的去解决，才能预知有哪些问题。 打破classloader正常委派机制我们在开始说了，正常classloader的加载模式的双亲委派，那么这个我们能不能打破了，打破之后，我们能够做些什么事情了，这里同学们就会明白，打破肯定是可以的，打破也很简单，我们理解了正常的加载模型，那么我们只要改变parent的指向就好了，类似改变parent指针，instant run的快速加载就是这么实现的，只是instant run里面还多了一个代理，其实也就是wrapper一个classloader去加载自己的dex。记住，什么时候我们会用到打破双亲模式的加载方式了，比如我们想加载一个热修复类，可以用这种方式替换数组插入的方式。instant run classloader图例: parent-classloader java classloader与android classloader的异同java classloader与android classloader 我相信很多同学都不怎么明白，我这里主要讲解两个最根本的区别 java的加载源是classpath，android的加载源是dex或者自定义path，java加载的class，android加载的是dex，但是最后也是加载的class，dex会经过解压。总体来说加载的数据根本没变。 java默认可以加载网络的class，defineclass可以定义class，android下面默认是不允许的，不支持url的方式去加载，如果你非要加载也是可以的，这个是android系统为了安全把这个方法从java层移除掉了，jni层还是保留的，底层的class生成还是defineclass，我们可以jni层调用这个方法实现class的生成。 android 类加载核心代码: android-classloader java define 生成Class代码 define-classloader classloader的运用场景classloader场景就太多了，比如插件开发，热修复，主题包，so修复等等都可以用这个实现，只有深入理解了classloader，我们很多高难度的场景才能对付。其实静下心来也不难理解。 classloader常见问题以及解决方法classloader我们在真正项目运用过程中肯定会遇到一些坑，比如不同的os的classloader被定制的面目全非，最坑的是阿里云的类加载器，这里就不过多吐槽，在插件化的时候，一定要单独处理对待，它的待遇就是不一样，还有360自家系统的classloader也要单独处理，其实这些都不难，就是坑，发现一个埋一个就好，理解原理了之后，后续问题基本都可以解决，只是可能有时麻烦点。这里的问题大多数是classloader内部的数据结构被改了。 总结总体来看classloader涉及到的东西还是很多的，我们平时开发可能很少注意，希望通过本篇文章，希望大家对classloader的应用层面有个好的理解，能够在以后的项目中遇到问题之后，用已有积累的知识点，快速解决问题。前面的文章分析了class的加载，也就是classloader真正加载class的生命周期，这篇是进一步的外部层面的补充。本来打算这篇是继续分析class的字节循环指令的，由于有同学对classloader不是很理解，就有了这篇文章的分析，下篇还是会按照正常套路分析字节码指令，敬请期待…… 最近访客","tags":[{"name":"classloader","slug":"classloader","permalink":"http://www.jackway.cn/tags/classloader/"}]},{"title":"2017我你前行","date":"2017-01-27T00:27:57.000Z","path":"2017/01/27/new-2017/","text":"2017我你前行，祝愿所有的小伙伴新的一年有新的收获, 鸡年好运~ chicken [福]新年快乐![福] [福]身体健康![福] [福]步步高升![福] [福]事业有成![福] [福]财源广进![福] [福]心想事成![福] [福]万事如意![福] ;","tags":[{"name":"2017","slug":"2017","permalink":"http://www.jackway.cn/tags/2017/"}]},{"title":"jvm-字节码指令(2)","date":"2017-01-22T10:20:31.000Z","path":"2017/01/22/jvm-字节码指令-2-结构指令/","text":"上篇介绍了基本的一些字节码指令，比如基本的数据操作，我们也大概的明白了字节码层面是如何对数据进行操作的，有的小伙伴可能觉得字节码指令跟汇编指令，smail指令有点像，没错，从结构层面上来说没有两样，不同的就是指令的含义不一样，也就是不同语言环境导致了指令的动作不一样，理解的思路都差不多，理解一门，其他都一样。有了指令基本的认识，那么必定会涉及到基本数据的操作，数据必然是流动的，不管是用户事件的输入，还是系统内部触发，最后必定涉及到数据操作，那么数据操作，程序结构在字节码层面是如何实现的，这篇文章就分析，数据判断，程序结构等指令，也是非常重要的，不管一个程序多么的复杂，我说过必定都是由数据，以及数据的操作指令组成，只有基础指令掌握的扎实了，我们才能解决复杂的问题，说了这么多，下面详细进行指令分析。 指令大纲 条件判断（if－else） 分支指令（switch） int-条件判断（if－else）所谓的条件判断只有3种可能，假如定义a,b两个变量，可能的结果由ab,a=b,没有其他可能了，我们写java源码可以这么写:12345int a=10,b=20;if(a&gt;=b)&#123; return a;&#125;return b; 对应的字节码:12345678910110: bipush 10 2: istore_1 3: bipush 20 5: istore_2 6: iload_1 7: iload_2 8: if_icmplt 13 11: iload_1 12: ireturn 13: iload_2 14: ireturn 这里只贴出了code属性的字节码，因为我们只关心这些，其中code属性中有些对常量池的引用等属性的引用，我们这里不关心这些，直接跳过。首先我们来看bipush 这个指令就是将10常量push到栈顶，istore_1将栈定pop也就是10存储在第二个变量里面，注意变量表的结构类似数组。bipush将20 push到栈顶，istore_2 将栈顶pop也就是20存储在第三个变量里面，iload_1 将变量2push到栈顶，iload_2 将变量3push到栈顶, if_icmplt 比较栈顶的2个值，注意这里的比较跟我们java源码的比较逻辑刚好相反，注意就好了，如果小于那么执行iload_1 将变量2push到栈顶，然后return, 否则跳转到iload_2 将3变量push到栈顶，然后return; 整个流程来看，字节码的执行还是很严格的，也是很符合我们的思维逻辑的，字节码多看就会了，初次接触可能会有些蒙，看了几次之后就好了。 float-条件判断（if－else）上面分析的是int的条件判断，接下来分析float的，有的同学可能会有疑问，不都是比较吗？为啥要分开来写了，确实，我开始也是有这些疑问，那是我们没有明白一个很重要的点，int要么成功执行，要么直接抛出NumberFormatException，但是浮点类型也有这两点性质，还有一点就是NAN值，其实还有无穷大属性，NAN根本是没有比较意义的，NAN的含义是不是一个数字，我们想想，不是一个数字的数，我们去比较有没有意义了，但是这种情况确实存在，那么我们程序也要处理，那么字节码怎么处理了，字节码这样处理，将比较结果push到栈顶，比较结果的值只有1,0,-1 3种可能，也就是开始说的，比较只可能出现的结果，那么这样就好处了，将栈顶跟0比较，就可以得到结果，如果是NAN规定将1push到栈，后面的操作指令跟int一样了，这里知道不同点就好，float比较指令用的:fcmpl,ifle 根据条件执行。double跟float一样，都是浮点类型，这里就不讲解了。 分支指令（switch）分支指令在我们开发中，也是非常常见的，但是不同jdk版本对分支常量的支持力度不太一样，最明显的就是后续版本jdk对String提供了支持，看上去是一个对象的比较，其实背后还是基本的比较组合实现的。分支指令可能对不同代码属性有不同的表现，这个是编译器决定的，也就是在编译的时候，可能对我们的代码进行优化，根据空间，时间的折中考虑，来决定用什么指令实现分支，jvm里面有两种分支指令: tableSwitch和lookupswitch 第一个就是table形式，跟数组一样，满足数组所有特性，我们最容易想到的数组特性就是查找最有，下表定位可以找到对应的数值，所以在数据跨度不是很大的情况下，tableSwitch 指令可以达到时间，空间的最有，但是如果跨度大了，就会浪费很多的存储空间。所以就有lookupswitch指令来实现，这个指令分支值也是排序的，也可以用不同的排序算法来实现最优查找，在一定时间复杂度内，不会需要额外的存储空间。对这两种指令的选择，由编译器决定，来优化。下面来看一个实例，更清晰的认识，这两种指令的实现方式, 源码如下: 12345678switch (1) &#123; case 1: break; case 3: break; default: break; &#125; 对应的字节码如下:1234567890: iconst_1 1: lookupswitch &#123; // 2 1: 28 3: 31 default: 34 &#125; 28: goto 34 31: goto 34 34: return 我们看到这里用的lookupswitch 这条指令，1:28 跳转到28行执行goto指令，goto 在我们开发中是不建议直接使用的因为会打乱程序结构，而在字节码中经常看到，直接实现跳转，goto 34 这条指令就是指定跳转的行号这里就是跳到34行，然后执行return。我们知道switch都有个default指令，也就是没有匹配的时候，默认的执行指令，这里直接return。 说到这里我们应该明白了数据的比较，分支处理指令，这是实现复杂指令的根基，一定要好好的体会，后续对象操作指令，其实也很类似，只是对象的操作比这更复杂些，涉及到引用链，其实也不难，今天就写这么多，下篇继续分析，分支指令的String处理方式，以及循环结构的指令处理，明白了这些，指令的基本操作到此就结束了，后续会有几篇讲解，一些对象上的指令，比如对象的操作，也就是方法的调用，对象字段的操作，包括实例字段，静态字段。敬请期待后续的分析…… 最近访客","tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.jackway.cn/tags/jvm/"}]},{"title":"jvm-字节码指令(1)","date":"2017-01-18T14:17:45.000Z","path":"2017/01/18/jvm-字节码指令-1/","text":"上篇文章比较详细的分析了一个class文件的基本结构,文件的内容虽然很简单，但是足以说明class结构的组成与本质，不管class文件多复杂，最后的文件结构都是按照字节有序的排序在文件中，所以了解class文件的结构是我们进行这篇字节码指令解析的前提，如果你还没有对class结构有所了解，可以先查看class结构这篇文章，对class有个初步的认识，这样再看字节码就相对好理解，jvm字节码指令的占用空间就一个byte,意味着字节码指令最多256个，无符号数据范围0-255,我们在上篇class结构的Code属性里面就看到对用的指令，只是指令操作码是以二进制出现，对应我们查表就知道对应指令的含义，说了这么多，还是那句话talking is a cheap,show me code.这篇文章，讲解最基础的指令，也是为了后续复杂组合打下基础。 变量我们都知道，不管什么语言，最基础的数据载体就是变量，显然程序中一切行为的操作都是基于数据，也就是基于变量操作，那么我们java中到底有哪些变量了，java里面大致可以分两大类: 基础变量 char long short int float double 引用变量 对象类型 数组 首先我们知道，从class结构分析中我们了解变量的存储是基于slot的，不超过32位的数据，占用一个slot，64的占用2个slot,引用类型也是占用一个slot比如我们定义一个基础变量:int x = 10;对应的字节码:120: bipush 101: istore_0 bipush 这个指令就是将10入操作栈,istore_0然后pop出并且存储到局部变量表中,对应的操作图示如下: variable 后面任何指令都是入栈，出栈的流程，只是有些指令操作起来比较复杂而已，我相信只要理解了基本的指令，其他指令也就是一些组合，并不会有很大的难度。我们再来看一个实例变量的字节码操作指令: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class com.example.MyClass minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#20 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #3.#21 // com/example/MyClass.a:I #3 = Class #22 // com/example/MyClass #4 = Class #23 // java/lang/Object #5 = Utf8 a #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/example/MyClass; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 MyClass.java #20 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #21 = NameAndType #5:#6 // a:I #22 = Utf8 com/example/MyClass #23 = Utf8 java/lang/Object&#123; public com.example.MyClass(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: aload_0 5: iconst_1 6: putfield #2 // Field a:I 9: return LineNumberTable: line 3: 0 line 4: 4 LocalVariableTable: Start Length Slot Name Signature 0 10 0 this Lcom/example/MyClass; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 7: 0 LocalVariableTable: Start Length Slot Name Signature 0 1 0 args [Ljava/lang/String;&#125;SourceFile: &quot;MyClass.java&quot; 我们重点看看Code属性就好了，我们知道是了变量的初始化其实实在构造函数进行的，首先我们看到aload_0 这个指令，这个指令就是将局部变量表中this(实例方法隐含参数)指针push到栈, 然后接下来执行invokespecial 这个就是调用父类的构造方法，在这里就是指向Constant pool #1 也就是Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 然后再次将this指针入栈,然后执行iconst_1 将1常量push到栈,然后putfield pop栈顶的值，写入Constant pool #1 对应的变量中，在这个实例也就是Field a:I,最后return 整个实例变量的赋值流程就完成了，写到这里，我想说，其实分析这个过程，很有利于我们对上层类加载，在初始化类的时候整个流程的理解很有帮助。 总结这篇文章主要目的是让大家明白指令的工作方式，基础操作变量的指令，以及内部执行逻辑，并没有写很复杂的指令，比如控制指令，逻辑指令，比较指令等等指令组合，其实这些都不很难，我们有了指令的认识，后续再看其他指令就很好理解，同时指令虽然最多256个，不算多，也不算少，在此我建议小伙伴们在分析指令，自己写的时候，可以查阅jvm指令文档这样更好理解，同时也是记忆的一种方式，看多了，自然就会了，也就不用查阅文档了。这篇文章主要是指令入门，后续讲解更多的指令操作，以及指令的灵活使用，我们都知道的，为了避免class打上preverify标志，同时也为了开发人员的透明开发，我们实现插件的方式去hook gradle任务，然后通过在每个class文件中插入一段代码，这个也就是热修复中插桩的一种方式。这里就需要直接修改字节码，加入对应的字节码指令。所以对字节码的指令了解是很有必要的。下篇继续分析jvm指令，大概还会写3篇相关指令的文章，然后一个asm实例，用这种方式实现方法执行时间统计，aop操作等。以前我们都是通过代理的方式，其实是比较繁琐的。敬请期待接下来更精彩的文章…… 最近访客","tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.jackway.cn/tags/jvm/"}]},{"title":"jvm-class内部结构深度揭秘","date":"2017-01-15T06:24:26.000Z","path":"2017/01/15/jvm-class内部结构/","text":"前面几篇关于jvm的分析，比如gc，内存分区，类加载，类验证等都是基于已有class文件进行分析的，我们并没过多的去关系class的内部结构，在大多数情况下，我们也没必要去了解class的构成，在开发层面，我们都是假定class已知，实际情况却是也是这样，我们通过开发工具，比如android开发中我们最为熟悉的开发工具，也是业界我个人认为最为强大的工具帮我们完成了class的生成，我们只需要关心最上层的源码编写，那有同学可能会疑惑，既然开发工具都帮我完成了，我们还有必要去了解内部吗？我们用过classloader加载一下不就好了吗？是的，说的很对，几乎99%的场景下，我们都是这样，但是假如一天遇到需要我们修改class内部结构的需求，那这时类加载就帮我们不了了，我们能够去完成需求的前提是，对class结构有一定的了解，不管如何，最为用java语言开发的开发者，都建议多少深入研究一下class的内部结构，这样不仅仅对写上层代码有帮助，更有助于我们对我们写的程序的把控，做到心理有底的代码必定bug会降到最低，说了这么多，这篇就来简单分析一下class内部的存储逻辑，jvm怎么能够识别class文件的。 class文件组成 在分析之前，我们首先要明白class文件的组成，其实我们分析每个文件都一样，必须先对文件的规范有一定 的认知，我们才能继续去分析，class文件我们明确一下几点就好了。 class文件是有8个字节为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，对于超过8个字节的数据，将按 照Big-Endian的顺序存储的，也就是说高位字节存储在低的地址上面，而低位字节存储到高地址上面，其实这也是class文件要跨平台的关键，因为 PowerPC架构的处理采用Big-Endian的存储顺序，而x86系列的处理器则采用Little-Endian的存储顺序，因此为了Class文 件在各中处理器架构下保持统一的存储顺序，虚拟机规范必须对起进行统一。 class文件结构采用类似C语言的结构体来存储数据的，主要有两类数据项，无符号数和表，无符号数用来表述数字，索引引用以及字符串等，比如 u1,u2,u4,u8分别代表1个字节，2个字节，4个字节，8个字节的无符号数，而表是有多个无符号数以及其它的表组成的复合结构。可能大家看到这里 对无符号数和表到底是上面也不是很清楚，不过不要紧，等下面实例的时候，我会再以实例来解释。 ps: 如果大家对字节序不是很理解的可以看看阿里阮一峰大神的这篇关于子节序的介绍，说的很清晰，相信小伙伴一看就会明白，但是还是建议，先理解子节序然后看后面的分析。 classfile内部抽象数据结构 classfile 上面的字段信息，相信小伙伴们一看就会理解的，其实就是一个数据模型描述，跟我们在平时开发写的实体类没有本质的区别，只是我们写的是业务层数据，而这个是底层数据结构的定义，含义不太一样，我们只要理解不同点就好了，这里我提醒小伙伴一个值得注意的就是常量池，为什么单独说这个，因为这个跟其他数组不太一样，我们知道数组大小是不可变的，是连续的，是读性能最好的等特性，不一样的是常量池真正存储的有效数据是池的长度－1，第一次可以理解为保留空间，不存储池的任何信息。下面就详细的分析数据结构中的每一个字段的具体细节。 u4(4个字节) magic 这个是魔数，可以理解为一个固定的数值，不同文件的这个值不一样，目的是为了，软件能够识别对 应文件，并能都执行，class就行jvm能够识别的，只要符合class协议定义的，jvm都能够去执行，比如png就是图片软 件以识别的，jvm能识别png吗？这个当然不行的，jvm是专为class服务的，后面有兴趣的可以写一个识别png的虚拟 机, 开玩笑，说这么多，只是希望大家明白一点，文件标志的意义。 u4 minor_version 表示class文件的次版本号 u2 major_version 表示class文件的主版本号，注意为啥要这些字段信息了，是为了兼容，jvm是下兼容的系统，意思就 是1.6的jvm可以很好的运行1.5编译器编译的class文件。 u2 constant_pool_count 表示常量池的数量。这里我们需要重点来说一下常量池是什么东西，请大家不要与Jvm内存模 型的运行时常量池混淆了，Class文件中常量池主要存储了字 面量以及符号引用，其中字面量主要包括字符串，final 常的值或者某个属性的初始值等等，而符号引用主要存储类和接口的全限定名称，字段的名称以及描 述符，方法的名称 以描述符，这里名称可能大家都容易理解，至于描述符的概念，放到下面说字段表以及方法表的时候再说。另外大家都知 道vm的内存模型中 有堆，栈，方法区，程序计数器构成，而方法区中又存在一块区域叫运行时常量池，运行时常量池中存 放东西其实也就是编译器长生的各种字面量以及符号引用， 只不过运行时常量池具有动态性，它可以在运行的时候向其 中加其它的常量进去，最具代表性的就是String的intern方法，说到这里，我相信很多小伙伴对intern这个方法不 是理解，不要急，现在简单理解从将符串放进常量池就好，后面分析String典型系列的时候，会深入分析这个方法到底 jvm为我们做了什么，以及应用 场的问题，解决方案等。这里不展开分析，自己心里纪录一下就好。 cp_info 表示常量池，这里面就存在了上面说的各种各样的字面量和符号引用。放到常量池的中数据项在The Java Vrtual Machine Specification Java SE 7 Edition 中一共有14个常量，每一种常量都是一个表，并且每种常 量用一个公共的部分tag来表示是哪种类型的常量。 常量池中不同的类型，通过tag来区分，tag对应的不同类型下表: CONSTANT_Utf8_info tag标志位为1, UTF-8编码的字符串 CONSTANT_Integer_info tag标志位为3， 整形字面量 CONSTANT_Float_info tag标志位为4， 浮点型字面量 CONSTANT_Long_info tag标志位为5， 长整形字面量 CONSTANT_Double_info tag标志位为6， 双精度字面量 CONSTANT_Class_info tag标志位为7， 类或接口的符号引用 CONSTANT_String_info tag标志位为8，字符串类型的字面量 CONSTANT_Fieldref_info tag标志位为9, 字段的符号引用 CONSTANT_Methodref_info tag标志位为10，类中方法的符号引用 CONSTANT_InterfaceMethodref_info tag标志位为11, 接口中方法的符号引用 CONSTANT_NameAndType_info tag 标志位为12，字段和方法的名称以及类型的符号引用 有了这个表，我们就可以很好的分析出class常量池信息了。 u2 access_flags 表示类或者接口的访问信息, 图例如下: classfile u2 this_class 表示类的常量池索引，指 向常量池中CONSTANT_Class_info的常量 u2 super_class 表示超类的索引，指向常量池中CONSTANT_Class_info的常量 u2 interface_counts 表示接口的数量 u2 interface[interface_counts]表示接口表，它里面每一项都指向常量池中CONSTANT_Class_info常量 u2 fields_count field_info fields[fields_count]表示字段表的信息。 classfile 上图中access_flags表示字段的访问表示，比如字段是public,private，protect 等，name_index表示字段名 称，指向常量池中类型是CONSTANT_UTF8_info的常量，descriptor_index表示字段的描述符，它也指向常量池中类型 为 CONSTANT_UTF8_info的常量，attributes_count表示字段表中的属性表的数量，而属性表是则是一种用与描述字 段，方法以及 类的属性的可扩展的结构，不同版本的Java虚拟机所支持的属性表的数量是不同的。 u2 methods_count表示方法表的数量 classfile 其中access_flags表示方法的访问表示，name_index表示名称的索引，descriptor_index表示方法的描述 符， attributes_count以及attribute_info类似字段表中的属性表，只不过字段表和方法表中属性表中的属性是不同的， 比如方法 表中就Code属性，表示方法的代码，而字段表中就没有Code属性。其中具体Class中到底有多少种属性，等到 Class文件结构中的属性表的时候再说说。 attribute_count表示属性表的数量，说到属性表，我们需要明确以下几点： 属性表存在于Class文件结构的最后，字段表，方法表以及Code属性中，也就是说属性表中也可以存在属性表 属性表的长度是不固定的，不同的属性，属性表的长度是不同的 实例分析123456package com.longway.test;public class Test implements ITest&#123; private static final int VALUE = 1;&#125;interface ITest&#123;&#125; 对应的字节码:123456789101112131415161718cafe babe 0000 0034 0013 0a00 0300 0f070010 0700 1107 0012 0100 0556 414c 55450100 0149 0100 0d43 6f6e 7374 616e 7456616c 7565 0300 0000 0101 0006 3c69 6e69743e 0100 0328 2956 0100 0443 6f64 6501000f 4c69 6e65 4e75 6d62 6572 5461 626c6501 000a 536f 7572 6365 4669 6c65 01000954 6573 742e 6a61 7661 0c00 0900 0a010015 636f 6d2f 6c6f 6e67 7761 792f 74657374 2f54 6573 7401 0010 6a61 7661 2f6c616e 672f 4f62 6a65 6374 0100 1663 6f6d2f6c 6f6e 6777 6179 2f74 6573 742f 49546573 7400 2100 0200 0300 0100 0400 01001a00 0500 0600 0100 0700 0000 0200 08000100 0100 0900 0a00 0100 0b00 0000 1d000100 0100 0000 052a b700 01b1 0000 0001000c 0000 0006 0001 0000 0002 0001 000d0000 0002 000e 下面我就来按照上面的结构规范来分析字节码，让我们从根本上认识class的内部。让我们从次揭开class的面纱，不再认为字节码有多神奇，其实就是有序字节存储。只是具有jvm的规范，要jvm去执行当然满足jvm的要求。在分析之前，首先介绍一个命令的使用javap -verbose classname.class 这个就是字节码反编译命令，通过这个命令，我们能够很清晰的明白字节码内部存储，以及字节码指令，这里说到指令，后面文章会单独来分析，jvm能够识别的指令集，注意不是cpu指令集，这两者还是有很大区别的。下面我对上面的class文件执行javap命令，输出的信息如下: 12345678910111213141516171819202122232425262728293031323334353637383940Classfile /Users/longway/Documents/gitRepository/blog/source/java/Test.class Last modified 2017-1-15; size 278 bytes // 最后修改时间 MD5 checksum 19286a103ea3a625ab3b4a3932fec15e // 文件的摘要值 Compiled from &quot;Test.java&quot; // 源文件public class com.longway.test.Test implements com.longway.test.ITest // 类常量信息 minor version: 0 // 次版本号 major version: 52 // 主版本号 flags: ACC_PUBLIC, ACC_SUPER // 访问标志符Constant pool: // 常量池信息 #1 = Methodref #3.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V // 方法引用 #2 = Class #16 // com/longway/test/Test // classinfo #3 = Class #17 // java/lang/Object #4 = Class #18 // com/longway/test/ITest #5 = Utf8 VALUE // 字面量 #6 = Utf8 I // int #7 = Utf8 ConstantValue #8 = Integer 1 #9 = Utf8 &lt;init&gt; #10 = Utf8 ()V #11 = Utf8 Code #12 = Utf8 LineNumberTable #13 = Utf8 SourceFile #14 = Utf8 Test.java #15 = NameAndType #9:#10 // &quot;&lt;init&gt;&quot;:()V // 名字和类型 #16 = Utf8 com/longway/test/Test #17 = Utf8 java/lang/Object #18 = Utf8 com/longway/test/ITest&#123; public com.longway.test.Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 2: 0&#125;SourceFile: &quot;Test.java&quot; 我们从输出的信息很清晰的可以看到，class文件的主体结构，我已经对应的写了注释，在这里不分析这个文件的细节，后面在分析字节码的时候，再来详细分析，这篇主要还是从根本认识字节码组成，对于后续的学习打下坚实的基础。说了这么多，下面进入实战环节。首先我们按照classfile的组成来分析。其实也不难，就是固定套路。自己学着分析一片基本就会了。 cafe babe 这四个字节我们知道就是魔术，开发八杯，java的超燃咖啡杯。说到这个，我们不得不去看一下java的发明 者，很性感。想看的就点击一下James Gosling 这个人真的很伟大。其他就不说了。后续的文章还会提到很多 java牛人，比如并发专家，这个人我想只要看过jdk源码的人，对他都不会陌生，他对java的贡献真的太大了。可以说没 他，java不会发展这么快。 0x0000 次版本为0 0x0034 主版本为52 0x0013 常量池大小19，注意真正有效的数据只有18个，0号元素为预留空间 0x0a tag值10 通过查表知道，是代表常量池方法引用信息，结构如下: constantspool-methodref u1 tag 意思是tag的描述占用一个字节,无符号，也就可以表示256中可能 u2 class_index 对应CONSTANT_Class_info 中的信息 u2 name_and_type_index 对应CONSTANT_NameAndType_info中的信息 上面字节码中: tag为10 不多解释 class_index 0x0003数值是3也就是对应池里面的第三个我们查表得知结果为：java/lang/Object name_and_type_index 0x000f数值是15也是对应池里面的的第15个通过查表得知结果为: &lt;init&gt;()V 0x07 tag值7,跟前面分析类似，查表得知为CONSTANT_Class_info，结构如下: u2 class_name 0x0010 数值是16也就对应池里面的第16个数据，我们查表得知结果为: com/longway/test/ Test 0x07 tag值7, 跟前面分析类似，查表得知为CONSTANT_Class_info，结构如下: u2 class_name 0x0011 数值是17也就对应池里面的第16个数据，我们查表得知结果为: java/lang/Object 0x07 tag值7，跟前面分析类似，查表得知为CONSTANT_Class_info，结构如下: u2 class_name 0x0012 数值是18也就对应池里面的第16个数据，我们查表得知结果为: com/longway/test/ITest 0x01 tag值1， UTF-8编码的字符串，结构如下:u1 tagu2 bytes 长度 0x0005值为5个字节u1 字节数据 56 414c 5545转换成十进制对应86 65 76 85 69 然后查询ascii表就可以得到结果为VALUE 0100 0149 对应结果I 0100 0d43 6f6e 7374 616e 7456 616c 7565 对应ConstantValue 0x03 tag值3 CONSTANT_Integer_info,结构如下:u1 tagu4 bytes 对应的值0300 0000 01 值就是1 01 0006 3c69 6e69 743e 对应ascii值为&lt;init&gt; 0100 0328 2956 对应ascii值为()V 0100 0443 6f64 65 对应ascii值为Code 01 000f 4c69 6e65 4e75 6d62 6572 5461 626c 65 对应ascii值为LineNumberTable 01 000a 536f 7572 6365 4669 6c65 对应ascii值为SourceFile 0100 0954 6573 742e 6a61 7661 对应ascii值为Test.java 0x0c CONSTANT_NameAndType_info tag 结构如下tagname 00 09 对应值&lt;init&gt;type 00 0a 对应值()V 01 0015 636f 6d2f 6c6f 6e67 7761 792f 7465 7374 2f54 6573 74对应ascii值为com/longway/test/Test 01 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 对应ascii值为java/lang/Object 0100 1663 6f6d 2f6c 6f6e 6777 6179 2f74 6573 742f 4954 6573 74 对应ascii值为com/longway/test/ITest u2 access_flags 0x0021 对应ACC_PUBLIC|ACC_SUPER u2 this class 0x0002 对应com/longway/test/Test u2 super class 0x0003 对应java/lang/Object u2 inerfaces_count 0x0001一个接口 u2 interface[1] 0x0004对应值为com/longway/test/ITest u2 fields_count 0x0001 有一个字段 field_info 结构如下: fieldinfo u2 access_flags 访问标志 001a==&gt;ACC_PRIVATE|ACC_STATIC|ACC_FINAL u2 name_index 名字索引 0x0005==&gt;VALUE u2 descriptor_index 描述索引 0x0006==&gt;I==&gt;int(integer) u2 attributes_conut 0x0001 对应一个属性attribute_info attributes[attributes_conut] u2 attribute_name_index 0x0007==&gt;ConstantValue u4 attrubute_length 0x00000002 u1 info 0x0008 ==&gt;1 field-type u2 methods_count 0x0001对应一个方法 method_info结构如下: u2 access_flags 0x0001==&gt;ACC_PUBLIC u2 name_index 0x0009==&gt;&lt;init&gt; u2 descriptor_index 0x000a==&gt;()V u2 attributes_count 0x0001对应一个属性 attribute_info attributes[attributes_count] u2 attribute_name_index 0x000b u4 attribute_length 0x0000001d u2 max_stack 0x0001 u2 max_locals 0x0001 //slot是虚拟机为局部变量分配内存的最小单元，在运行时，对于不超过 32位类型的数据类型，比如 byte,char,int等占用1个slot，而double和Long这种64位的数据类型则需要分配2 个slot，另外max_locals的值并 不是所有局部变量所需要的内存数量之和，因为slot是可以重用的，当局部变量 超过了它的作用域以后，局部变量所占用的slot就会被重用 u4 code_length 0x00000005 u1 code[code_length] 2a b7 00 01 b1 u2 exception_table_length 0x00 没有异常信息 {u2 start_pc u2 end_pc u2 handler_pc u2 catch_type } exception_table[exception_table_length] u2 attributes_count 0x0001 有一个属性 attribute_info attributes[attributes_count] 0x000c==&gt;LineNumberTable LineNumberTable 结构如下: u2 attribute_name_index 0x000c==&gt;LineNumberTable u4 attribute_length 0x00000006 u2 line_number_table_length 0x0001 {u2 start_pc u2 line_number }line_number_table[line_number_table_length] 0000==&gt;0002字节码行号对应源代码，这对于定位 代码很有作用 u2 attributes_count 0x0001 一个属性长度 attributes_info attributes[attributes_count] 000d==&gt;SourceFile我们再来简单的看一下SourceFile数据结构: methon-info u2 attribute_name_index 0x000d==&gt;SourceFileu4 attribute_length 0x00000002 除了之前的offset的剩余长度u2 sourcefile_index 0x000e==&gt;Test.java总结通过分析class的内部存储，我们对class的结构有了基本的认识，但是我还是希望小伙伴们自己分析一片，这样可能对class的结构理解更深刻，在实际运用过程中也会更加得心应手，分析完，并不代表就结束了，这仅仅分析了class而已，虚拟机加载完class到内存，然后按照我们的分析方式解析，分配内存，然后解析语义，然后还需进行编译才能去执行。这也就是class跨平台的原因，编译一次，到处运行，只要满足jvm规范，屏蔽底层细节。有了class结构的认知，下篇带领大家一起深入jvm内幕，也就是jvm最后一篇，也是最为重要的，在实际应用中用的最多的，比如2016年最火爆的技术，实时热修复线上bug技术，热更技术，有些技术用到asm这个工具实现编译时透明插入代码的。这里用到的技术就是对class文件操作，hook对应的指令，插入指令，达到变更操作行为的目的。所以我们还是很有必要对jvm指令深入理解一下，jvm指令不多，我们分析class结构的时候，看到code属性里面有个code指令集，占用一个字节，也就是说，jvm指令集的全集256个。分析class确实比较耗时间，但是从中可以明白很多一些设计思想，特别可以理解底层协议设计，设局结构设计等等。敬请期待下篇jvm指令解析…… 最近访客","tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.jackway.cn/tags/jvm/"},{"name":"class","slug":"class","permalink":"http://www.jackway.cn/tags/class/"}]},{"title":"sdk-design-rules","date":"2017-01-12T03:17:05.000Z","path":"2017/01/12/sdk-design-rules/","text":"Twitter 的 Fabric 是知名的注重质量的 SDK，并已部署在数十亿的设备。在这次dev 演讲中，来自 Twitter 的 Ty Smith，揭示了 Fabric 团队创建他们 Fabric 的各种原则，特别是在 Android 方面。通过深入参与技术决策团队，Ty 了解到很多信息，他展示了团队在创建这个 SDK 过程中，学到的各种经验心得，关于稳定性、性能、SDK 体积控制、以及对于一些特殊情况的处理这些方面。无论你现在或将来想要建设一个 SDK，通过这次演讲你应该能收益很多关于设计 SDK 的伟大想法。 APIs &amp; Fabric作为开发者，我们中的大多数人不得不使用 SDK 和 API，但经常地，我们会遇到一些令人沮丧的或设计不好的东西。要使得开发伟大的应用程序更加轻松，作为核心的软件开发工具包还有很长的路要走。在 Fabric 上，我们很关心开发者的经验，我们花了大量的时间，使我们的 SDK 更容易和更有趣。我的名字是 Ty，在 Twitter 的 Android Fabric 工程师团队。我想与你们分享一些我们在开发 SDK 过程中学到的经验。 那么 Fabric 究竟是什么呢？它是一套 Twitter 开发的模块化开发工具包，Twitter 共享了一个共同的移动和Web平台，用于减少占用空间和提供一致性的解决问题方案，旨在提升第三方移动 App 的质量。我们去年发布了 Fabric，这是完全免费的。我们相信这是一个伟大的方式来引导你的移动应用程序。就在上个月，我们宣布了多个外部合作伙伴，现在正在基于Fabric 进行开发，未来将有更多高质量的内容提供给大家。 我们建立 Fabric SDK，我们保持了几个目标，帮助引导我们进行开发。这些原则决定了我们开发 API 和做决策的选择。这些想法可以融入你自己的SDK或甚至你的应用。我们很高兴能够看到大家离开这里后，在未来开发的你们的 SDK 中采纳和我们一致的想法。 注意事项在我们进入 library 或 SDK 编码之前，我们有必要考虑几个方面。 客户需求首先要考虑的是要找出你在 library 里的实际服务的对象是谁，是内部开发人员还是公共开发人员？谁会使用它？它带来的新价值是什么？市场上已经有了一个解决办法吗？如果是这样的话，你应该是去对其进行开发和贡献而不是重新创造一个“轮子”。 开源 vs. 闭源考虑开源与闭源是一个大问题。开源通常会让你更好地通过社区，获得更稳定的软件，以及更热心的内部工程师。然而，需要思考的事，你的 SDK 仅仅是集中于一个工程点呢？还是说它是一个完整的产品，但有一个后台服务呢？因此，仔细考虑你将采用哪一种许可证(开源协议)。例如，如果你使用 GPL 许可，那么将会使得用了你的 SDK 或 library 的人也必须得使用 GPL 开源协议。更灵活的许可证可能是 Apache 2 或 MIT 许可。 Binary 打包特别是对于 Android，打包你的代码并不一定是简单的。你有三个问题需要考虑。首先是对于一个标准的库项目，开发者将他们包含到他们的代码中，并且由 IDE 帮忙连接它们，它是非常灵活的，但是如果他们需要分叉(fork)，他们得如何保持更新？在 Java 的世界 jar 包是另一个好例子——很标准的二进制包装。不幸的是，对于 Android，它们不能捆绑打包自己的资源文件，所以对于一些和视图相关的 library 一般都不能采用 jar 方式打包。最后，在 Android 世界还有一种打包方式即 aar，它是谷歌现在支持二进制打包方式。这是一个压缩的容器，包含了编译的源代码以及资源文件，它可以通过 Gradle Maven 依赖源从而非常方便快捷地分发给开发者。 Hosting the artifacts最后的考虑是在哪里托管你的打包结果。Maven Central，是标准的仓库。然而，他们都需要开源许可，因为他们想保护他们的服务的用户，他们不希望有人会隐式地拉下来一个二进制包，并选择一个他们没有得到审查的服务条款。如果使用了另外的资源库（如果你有一个专有的二进制文件），则开发人员必须手动添库到编译脚本中。 创建伟大的 SDK在创造 Fabric SDK 的工作是一个梦幻般的学习过程。我们的目标就是涵盖这五大方面：易用、稳定、轻巧、灵活，很好的支持。我们相信伟大的 SDK 要实现这些得走很长的路。 易用其中的一个关键就是可用性。我们认为产品应该是易于使用的。那么所谓的易用到底是什么呢？我们想创造一种最简单的方式，让人们在他们的应用中开始使用 Fabric. 如果它是易用的，它应该是不需要侵入太多你的代码或者你需要做很多繁琐的集成工作。只要在你的代码中新增一行我们的代码，就可以使用它了，类似这样：1Fabric.with(this, new Crashlytics()); 但易用的同时，有时还得能够定制，许多开发者可能希望更多的定制。要做到这一点，我们使用的 Builder 生成器模式设置一些选项，比如设置一个监听器好让程序在应用程序崩溃之前通知你。 1234567Crashlytics crashlytics = new Crashlytics.Builder() .delay(1) .listener(createCrashlyticsListener()) .pinningInfo(createPinningInfoProvider()) .build();Fabric.with(this, crashlytics); 对于 Fabric SDK，我们需要一个 API key 作为连接我们网络服务器的验证密钥。这是我们要开发人员处理的事情，但需要尽量减少所需的工作量或者说繁琐度。我们的标准方法是：通过我们的构建插件提供的方式，并将其注入到清单(manifest)文件中。这里是一个例子，使用 metadata 在清单文件中插入数据： 123456&lt;manifest package=\"con.example.SDK\"&gt; &lt;application&gt; &lt;meta-data android:value=\"01235813213455\" android:name=\"com.fabric.ApiKey\" /&gt; &lt;/application&gt;&lt;/manifest&gt; 当 Fabric 在初始化的时候，我们可以通过 package manager 获取到我们插入在清单文件中的 API key 并且继续后续工作。另外，我们可以允许其他的方法来管理这个 API key 的值，对于开源项目这么做可能会更好（保护 key 的值，因为有时我们对项目进行开源，但 key 不想开源）。例如，您可以创建一个属性文件，然后我们将在运行时读取该目录文件内容。 易用性的表征除了我刚才提到的实施细节，我们喜欢在设计 API 时考虑这些特点：第一个是 直觉。如果一个接口调用的行为恰好是开发人员预期的方式，而无需参考文档。我们发现，在你的 SDK API 中使用 一致 的命名，也是有助于使用者理解。使用平常的表达语言来命名你的方法，以及类似的设计模式。并且遵循各个平台约定俗成的命名规则，比如 iOS 和 Android 平台，它们各有不同的命名规则。最后，如果 API 很难被误用，将可以防止一些错误的发生。验证输入的参数，和书写明确的文档，将使得开发者在使用的时候，能够有信心和避免错误。也会带来一个更愉快的体验。 直观性让我们看一个反直觉的例子：123URL url1 = new URL(\"http://foo.example.com\");URL url2 = new URL(\"http://example.com\");url1.equals(url2) 这一个感觉，将影响很深，也是 API 中最难的部分。当使用一个伟大的 API 时，我们可以猜测它是如何表现的。在这个例子里，我们将期望 equals 执行某种标准化的字符串比较。但是实际上反直觉的是，equals 代表如果这两个 URL 解析到相同的IP地址，在 Java 中的实现，将返回 true，这里的原因是这个 API 的实现十分有趣：它发射同步的 DNS 请求。谁会想到？阻塞调用线程是一个意外行为的例子，在 API 中应该是非常明确指出的。 一致性举一个例子，Fabric 和 Crashlytics 的初始化方式便都是一致的。在初始化 Fabric 或 Crashlytics，两个不同的二进制依赖库文件，正如我们之前看到的我们允许它们使用同一模式建造。用户可以使用无参数构造函数，或定义辅助方法来设置默认值，另外，这两者都提供了一个可用于重定义对象的生成器(builder)。 防止误用最后该讲到如何防止误用了。例如，从 Fabric Builder 的构造函数我们可以得知，Context 对象是必须的，而其它一些 setter 是可选的。一旦我们在构建的阶段中创建实例，这些可选参数也就一并被初始化。这样设计的话，开发人员使用 API 将不能不提供 context，但可以使用其它 setters 在另外的闲暇时间。我们相信这样就很难被误用了。 怎么设计 API我们如何才能设计出高品质的 API 呢？让我们来看看我们的设计流程。设计 API 是很难的，它通常不只是一个工程师独自坐在一个黑暗的房间，决定该是什么样子，它需要整个团队付出大量的工作。我们在 Fabric 的 API 设计上第一个重点就着眼于我们将支持的几个平台。我们创建一个设计文档之前，任何实施工作都是这样做的，进行讨论在这些平台上，不同的方法的优点和缺点。有一句话我很喜欢：一个 API 就像一个婴儿。他们很有趣，但他们需要18年的支持。任何 API 我们都必须要长期地支持，所以我们要让大家感觉到，我们正走在正确的路上，才能才久坚持支持下去。最后，即使我们可以让 iOS 或者 Android 开发中愉快地使用我们的 API 了，我们还需要建立相关的平台，首要的就是让开发者们感到最舒服的。 API 稳定性现在我们已经设计了一些很容易使用的东西，让我们来讨论一下我们如何能获得开发者的信任，相信这是非常重要的。因此，确保软件开发工具包是可靠的，他们不影响应用程序本身的稳定性。大家都知道，相比开发应用程序，开发一个 SDK 需要更高的稳定性要求。让我们来看看如果产生了一个错误将会有什么影响。如果一个应用程序有一个关键的错误，阻碍了它的用户使用，它可能仅仅需要发送一个新版应用程序给顾客进行更新即可。而如果是我们 SDK 发现了一个漏洞，我们很快修复它，它可能还需要一个月才能到达你的用户，在此期间，你的用户就会有很不好的体验了。显然，如果一个 SDK 有一个严重的 bug，它的修复更新到达时间要长得多。这可能需要几个月，用你的SDK应用程序的用户才能得到错误修正。应用程序开发人员可能需要数周才能注意或升级您的 SDK 版本，并进行修复、测试 bug。所以说确保一个 SDK 的稳定性是我们的最高优先事项之一。 如何确保稳定?作为开发人员我们可以做什么，以确保尽可能高的稳定性？有一些事情是我们开发过程中的关键。首先，代码审查是非常重要的，必须得认真对待它们。然后，通过不断地问自己“这个代码有什么问题吗？”我们可以这样试着去问自己，以达到尽可能的防守。如果能够自动获得一些基本的正确性保证，也可以在早期帮助捕捉错误，所以单元测试是非常有用的。另一方面，人们经常忽略的是：在用户使用初次使用进行测试时候，使它能够运行你的一些 SDK 代码，这样做他们可以在你的 SDK 集成时进行捕捉 bug。最后，持续整合(译者注：维基百科词条 - 持续整合 )和”吃你自家的狗粮”（译者注：维基百科词条 - Eating your own dog food ）也都可以作为你的保护层，可能有助于早期快速识别问题。 使 SDK 具备可测试性和可模拟性有一些技巧可以让你的 SDK 具备更好的可测试性。其中，为了测试，有时我们需要进行模拟，模拟(mock)类作为真实类的仿制类，它没有真实操作，并且允许被重写调用和验证方式。 通过避免静态方法,您可以允许在模拟实例上进行操作任何方法的调用。如果您将使用静态方法，需要确保它可以被隔离，并且您将提供所有的依赖关系，并且没有基于任何状态。 许多 mocking libraries 对于 final 的类也会产生许多问题，所以要考虑你的类扩展。在你的模拟类中不应该存在 public 属性，所以需要被访问的一切都应该通过一个访问的方法来运行。 在你的 API 中使用接口。如果您的输入点使用接口，设置类来测试将更容易。该接口允许开发人员进行重写的行为，比如契合模拟服务器或在内存中存储，来替代真实场景真实存储的开销。 最后，需要考虑到测试人员不需要构造多个层次深度的模拟。这个鼓励测试的原则应该被写入你的指引文档，并提供更稳定的测试框架。 测试用例有一些 class 很难被模拟，比如 final 类型的，它将创建它自己的依赖关系，并且是一个基于状态的单例。这在 Java 中是很常见的，虽然它通常是一个反模式。这使得它在隔离测试中非常具有挑战性。那么，我们能做什么来解决它？其实只要有一些小修改，我们可以使这些难解的点变得更容易测试一些。 12345678910public class Tweeter &#123; private Network network; private public Tweeter(Network network) &#123; this.network = network; &#125; public List&lt;Tweet&gt; getTweets() &#123; return getNetwork.getTweets(); &#125;&#125; 与其把它作为一个单例，为什么不把它做为一个实例？开发者可以自己去重用它，缓存，或者做其它的事情。删除在 class 中的 final Mockito 或其他框架就可以模拟它了，同时也能让 SDK 在初始化、构造时候管理它的依赖。依赖注入不仅仅是一个框架，它还是一个帮助组织代码的设计模式，使得代码更具有模块性和可测试性。 优美的降解开发者经常是容易不耐烦的，所以有一些错误越尽早抛出就越好。如果你一直在使用 Gradle 你应该会明白我的意思，一些错误如果在 build 期间不能通过总是好于 build 完成之后5分钟才出现错误。你应该 把一些可以预期的异常抛出，以便于开发者能够尽快知道这些异常，比如在这种情况下，开发者试图设置一个 null 的 logger 到我们的 builder 里，我们得马上抛出一个异常，这样他们就可以很快知道并解决他们的错误。然而，你得保证你的 SDK 在生产环境中绝不会出错，让你的代码持续运行在他们的应用中，是你保证开发者们信心的唯一方法。他们的应用程序往往是他们生计的依赖，所以他们不会喜欢去赌着使用一个经常崩溃的库。所以当他们在调试过程中出现问题的时候，你可以提供额外的信息，写清楚这个 Exception，但要隐藏在生产过程中可能出现的问题，这样允许他们的应用程序的其余部分继续运行。你的 SDK 的出现问题可能对你来说是一个大问题，但并不是世界末日。作为一个开发者，你使用 SDK，你的应用程序应该增加价值，而最糟糕的事情就是你引进了某物反而使得原本多价值降低了甚至完全破坏用户体验。开发者们，包括我自己，不需要任何人来帮助我们写一个糟糕的 App。 轻量除了稳定，用户不太可能下载大的应用程序，这意味着安装包的大小是一个关键内容。下载软件产生的流量需要用户去付钱，所以即使你的应用是完全免费的，用户也得为下载它付出流量。在许多新兴市场，因为下载速度太慢，所以很多用户不爱下载大型应用程序；在某些市场，用户主动选择更新的应用仅仅基于更新日志和添加新的特性是否值得，因为他们需要支付每千字节流量费用。让我们来讨论一些 Fabric 用于保持轻量的技术吧。有一些伟大的第三方库，可以真正给予贡献于你的应用程序，但当涉及到 size 规模和影响时，他们会他们显得不自由。例如，图像加载方面有各种不同体积大小的图片加载库。其中 Fresco，是比其他任何一个第三方库都还大量级的一个库。然而，它对于旧设备有更好的支持，加载速度快而且内存友好，并支持渐进式JPEG。作为一个 SDK 你应该努力平衡你的尺寸与功能。因此，要注意引入第三方库，以确保它们只满足所需的内容。使用开源库有很大的优势，因为这些库往往经过很多的测试了，大家都使用得很好，并且他们有定期向他们提供更新的社区。这通常提供了一个更好的方案。在我们的 Twitter SDK，我们利用 Square 的 RetroFit 这个库作为一个依赖来简化我们的 API，而且也能使我们提供更好的可扩展性，这是值得的。 报告二进制文件(binary)的大小12345678task reportSdkFootprint &lt;&lt; &#123; def sdkProject = project(&apos;:clients:SdkProject&apos;) def nonSdkProject = project(&apos;:clients:NonSdkProject&apos;) def footprint = getSizeDifferent( new File(&quot;$sdkProject.buildDir&#125;.../Sdk.apk&quot;), new File(&quot;$&#123;nonSdkProject.buildDir&#125;.../onSdk.apk&quot;)) println footprint&#125; Dalvik 方法数量限制很多人应该都会遇到过 Dalvik 65K 的限制吧？不过你们可能不熟悉这个错误的具体原因，对于方法的调用，可以通过在 Android 一个 DEX 文件，而它的引用的数量有限。问题的关键是，DEX 的工具，在编译时，试图把所有的方法引用到一定的空间中，但引用数目大于空间所能容纳的数目，导致分配失败。现在你可以使用 multidex 来解决这个问题，但这增加了在较旧的设备上应用程序的加载时间，它的初始化时间显著增加，它并不适合一些较新的设备用户以外的人。它甚至某些流行的三星设备上会导致出错，并导致应用程序崩溃。这些特定的设备有数以百万计的设备，在欧洲和亚洲都是很流行的，所以说这个解决方案真是迫不得已，能不触及尽量不要触及。但如果开发者遇到这个问题，在他们去使用 multidex 或类似的东西之前，他们经常决定审核他们的第三方库，选择是否可以减少应用程序方法数量的库。所以我们的目标和建议是尽可能地使你的库模块化和精益。我们用一个伟大的库被称为 dex-method-counts 在 Gradle 中，它包装了一些Android 构建工具对每个第三方库的方法数量并给出了详细的数据分析。这让我们快速洞察到我们的库大小和我们的依赖的大小。 模块化我们想要模块化开发人员需要的特定功能。我这样做是通过指定一个树的传递依赖关系。所以，我们有两个例子展示如何初始化 Fabric： 容易整合的：1Fabric.with(this, new Twitter()); 更多控制的：1Fabric.with(this, new TweetUi(), new TweetComposer()); 第一个例子让你马上开始，其次是一个拥有更多定制的版本，在这里你可以选择需要的特定组件，然后它们才生效。让我们的 SDK 尽可能小，我们着眼于模块化来设计我们的架构。就像我们讨论过的，在 Android 上二进制文件的大小和方法计数是非常重要的，所以这使我们能够尽可能高效。因为如果我们利用 AAR（标准的通过 Maven 提供标准的库），我们可以使用分解依赖来满足我们的需求。在架构 Twitter SDK 堆栈，所有的一切都建立在 Fabric 上，它提供共享的 common 代码给所有我们的 SDKs. 我们建立了 TwitterCore 层，它提供了登录和 API 客户端和其他一些核心功能。然后，我们才有基于特征的 SDKs，像我们的 Tweets，我们的 composer，我们的短信登录基础设施；这些特点都可能是你使用我们 SDK 的理由。最后，我们提供了一个接口，通过传递依赖关系将其包装起来。这允许应用程序开发人员根据他们需要的层次结构选择组件。 压缩数据除了注意 SDK 本身的大小之外，我们建议你在“压线”之前进行压缩。我们可以明显看到，不同格式之间有压缩大小差异，如 XML 和 JSON，一起使用jzip压缩格式，或二进制格式 Protobuf。有些人可能不熟悉 Protobuf，它是一个二进制的压缩格式，在服务器和客户端接口使用一致的预期协议，使得不需要将所有字段都进行传输。它可以非常高效地进行序列化和反序列化。 批量处理请求有效地发射是避免消耗过多电源功率的关键。Android 有三种典型的能量状态：全功率、低功耗、空闲状态或称待机状态。在高功耗的时候进行统一的网络传输，比在空闲的时候断断续续进行多次传输来得节约时间和节约电源。对于在典型的3G设备上每一个数据连接，网络接收模块会产生约20秒的活跃时间。这意味着如果你每分钟有三个网络连接，我们将会保持这个网络接收模块不断地处于激活。通过批处理这三个连接，我们可以在这里减少20秒的启用速率，以及至少40秒的待机或空闲时间。不过对于这个方面，有一个例子，说的是天真统计分析 SDK，它们有时会不停地 ping 你的服务器，大约20秒一次，仅仅是为了告知服务器你的应用当前处于前台。这么做的后果就是会造成网络接收模块一直处于激活状态，并且把电源耗尽又没有传输什么实质上的数据内容。 异步任务保持 Fabric 的轻量部分方式是，我们应该清楚地知道何时在主线程做的工作何时在后台线程工作，我们建议在你的应用程序启动时候初始 Fabric，因此它的初始化将在主线程，我们从我们周围很多顾客那里听到大家都是比较关注启动时间的。为了缓解这一点，我们做了非常有限的一些同步工作，然后立马返回到开发者的 application，同时在后台继续做一些毕竟耗时的运行工作，以保持您的应用程序下次能够快速启动。有些事情需要用同步做的一个例子：如果你使用在使用我们的 Crashlytics ，你得立即使用它的 crash handler，因为一旦崩溃异常发生在异步初始化 crash handler 完成之前，就会捕捉不到这个异常。 灵活性一个 SDK 的开发者没有像应用开发者那么多的选择权。你不能选择你的设备，API level，或客户。你需要支持更大范围的设备，应用程序开发者并不局限在选择你的SDK，所以提供最大程度的灵活性是很重要的。 建立工具支持灵活性的一个体现是，可以让开发者选择不同的依赖管理器或者构件工具来引入或集成你的库。我们提供一些主要的开发工具插件支持，包括 Gradle, Maven, 和 Ant. 我们还为通常的 IDE 提供 GUI 插件，以及一个帮助开发 Mac 和 iOS app 的应用。尽管我们这是主要在讲 Android 方面开发 SDK 的内容，但我还是忍不住想告诉大家一个好消息就是我们最近完成了令人兴奋的 CocoaPods 支持，这将非常方便于 iOS 开发者使用我们的 SDK. 尽量选择兼容最低的系统版本灵活性的关键是了解您的 SDK 用户的需求。然后做出需要支持的最低系统版本的决定。我们很希望我们的 SDK 能够尽可能支持更多的系统设备。对于这一点，降低支持最低操作系统版本是很有必要尽力去做的。但另一方面，兼容低版本也是要付出代价的。并没有什么直接的法则能够告诉我们如何才能在繁琐度和更好的兼容性上确定平衡。支持旧的操作系统版本，通常意味着不利用更加好用的新接口，同时还要面对一些旧版本存在的问题。初次之后，你还要花费更多精力去测试你的代码之正确性。一般来说，SDK 会比应用软件在支持的最低系统版本的选择上，更近保守。例如，Crashlytics 提供了 Android 2.2 的支持，因为这是一个还基本实用的 Android 应用程序。而不是像一些应用程序，它们仅支持某一操作系统的版本，它们关注用户数量而去选择最佳系统版本。另一个重要的部分是能够检测出你正在运行的 Android 版本，所以你才能知道，哪些是可以调用的方法。通常，SDK 支持更老版本的 Android SDK。这对我们来说是非常重要的，因为我们想提供最大限度的设备支持。 Android Manifests在 Android 系统上，运行时兼容性是灵活性的重要组成部分。Android 开发者都知道，一个应用程序的元数据(metadata)在 manifest 文件中声明，一个 apk 一个 manifest 文件。此外，每一个你包含进来的 aar 都会带一个 Manifest 文件，只是在 build 的过程中，Android 工具会自动帮它们合并到一个 Manifest 里面。这意味着，如果一个 AAR 的 Manifest 会影响最终 Manifest 的生成，比如新增一个权限声明，这对于开发者来说是很难注意到的。 权限权限是任何 Android 应用程序的关键。在 Crashlytics 我们利用 wifi state permission 可以更好地管理上传崩溃日志。在 Android 的棉花糖系统上，这是属于正常水平的权限，这意味着它还需要在 manifest 文件中声明并同意。然而，我们没有在我们的清单中声明这个权限，所以，如果使用了我们 SDK 的开发者想要上传崩溃日志，就必须得在他的清单文件中声明上这条权限。如果开发者声明了那条权限，我们在下面的代码中就能够知道拥有这个权限了。 123456protected boolean canCheckNetworkState(Context context) &#123; String permission = Manifest.permission.ACCESS_NETWORK_STATE; int result = context.checkCallingOrSelfPermission(permission); return (result == PackageManager.PERMISSION_GRANTED);&#125; 我们只需要检查上下文对象中的权限，以判断是否已授予该权限。如果没有获得该权限也没办法了，我们不能为了权限而可能影响到安全异常。一个 SDK 可以在运行时检查是否被允许使用某权限，如果可用再调用相应的 API.很多时候我们都需要回退机制，但是在这种情况下，如果我们不知道WiFi或互联网的状态，我们必须假定它总是连接尝试，让超时发生。 可选的功能有很多 Android 设备的存在，同时有很多各式各样的特性或者功能可能其它机器设备并没有，比如有的有 Kindle Fire 而有的没有，有的设备甚至还没有摄像头。如果你正在构建一个基于相机的 SDK，你会在清单文件中使用相机。这就要求商店不要将应用程序展现给一个没有摄像头的设备。我鼓励你，把这个功能列为可选的，并允许你的库在运行时检测和修改它的行为。在运行时检测硬件功能非常简单。您只需要查询 package manager 该特定功能是否存在即可。这样以后你的应用程序可以确定哪些功能可以使用了。以我们的相机库示例，您可能还允许用户浏览照片和上传照片，只是他们不能够在没有相机的设备上拍照就是了。 Classpath 检测有很多很好的第三方库可以节约你的开发时间以及帮助你开发更好的 SDK. 当我们提供 SDK 给用户，可能需要检测用户是否有引入这些可选的第三方库，比如 RxJava 或者 Square 公司的 OkHttp，如果有，我们就可以利用它们提供相应的支持。但你没必要把这些包括到你的 SDK 当中，因为我们前面说了，保持轻量是最好的。 1234567private boolean hasOkHttpOnClasspath() &#123; try &#123; Class.forName(\"com.squareup.okhttp.OkHttpClient\"); return true; &#125; catch (ClassNotFoundException e) &#123; &#125; return false;&#125; 在这个例子中，你可以通过 class path 来检测 OkHttp 是否存在。你可以告诉用户可以引入这个第三方库进行更好的支持，但没有必要主动把它们包括到你的 SDK 当中。如果有，你可以利用，如果没有，你也可以有你的另外选择。 可扩展类和接口除了运行时检测，我们不能满足每个开发者的需求。我们的 Twitter SDK 提供了易于使用和流行的一些特性让用户去发现。我们预先就会准备好，帮你简化签名操作，我们使用持续的 token，签署了所有的输出请求。但是，如果你想使用一个我们 SDK 目前没有提供的 Twitter API 功能怎么办呢？如果是这样，你可以继承 Twitter API client，并且提供你的 retroift 接口，我们可以接受它并帮你进行签名。正如我们所知道的，开发人员有很多工具，有很多的选择，他们需要在他们的代码中保持灵活性。这是很现实的。我们提供可扩展的接口，使用 Fabric，使开发人员可以利用扩展他们想要的功能接口。这里还有一个例子是日志记录。有许多不同的库来使用，我们提供了日志接口，以便它可以在 Fabric 开始前提供实现，然后我们将尊重并使用开发人员的日志记录需求。但如果开发者选择不配置他个性的日志内容，我们提供一个健全的默认日志，便是标准的 Android Logger.另外，对于 Java 之外的方面，我们也支持让用户自定义他们想要的界面风格，比如开发者可以修改 color 的值，这些值将被应用于 TwitterUI SDK. Callbacks制定灵活代码的一部分，就是允许开发人员选择监听一些事件发生并获得通知。在我们的 builder，我们可以设置同步或异步任务结束的时候进行回调，也可以设置如果出错了可以得到回调通知。它允许开发者根据自己的状态和所获取的信息进行定制决策。 良好支持的 SDK当你完成了你的 SDK 开发的时候，并不代表着你的 SDK 真正完成了，你还需要有很多开发之外的内容要做，要建立开发者交流的社区，还要有 Apple 文档、Java 文档，以及 README 文档，另外还有很重要的就是要有使用你的库的示例教程。添加注释 给你的所有 public 的内容，以及顺带说明一些使用案例。发布简明的 示例(sample)代码，让使用的人可以遵循着你的代码进行初次尝试。但切记不要把你的示例代码写得太复杂或者在无关紧要的内容上纠结太多，不然会导致用户花费更多时间去学习你的示例代码，并且使用到他们的项目中时候，产生了很多疑问或者 bug.记得思考一些你想废弃的旧版本和方法。你们有多少人没有回头看旧的代码？除了去重写重构这些代码和方法，你可以需要对于旧的不要的代码进行废弃注解提醒。尊敬版本更新日志，这是一个你和开发者通过你的 SDK 沟通的方式，你可以去知道他们需要什么，而他们从你们的 SDK 更新日志中获得他们是否需要你这个新版本的信息，如果值得，开发者们就会决定更新到目标的这一个版本。最后，使用开发者预期的、常用的交流社区或称交流方式。如果这是一个开源库，应该是使用 GitHub 的 Issues，关注 Stack Overflow，Freenode. 以上是sdk的设计理论，几乎已经覆盖很多层面，但是经过我个人的思考，我觉得还有几个可以补充的方面： sdk的容错能力 sdk热修复 sdk混淆原则 总结 以上是twitter Fabric 伟大sdk的一些思考，通过个人理解与学习，其实开发一个伟大sdk的难度还是很大的，需要从sdk本身，sdk的使用者，sdk辅助平台等角度思考，同时还需要尽量透明，即使在sdk出现内部错误的时候，我们可以通过热修复的方式实时修复，不影响主app，这点很重要。这篇文章只是一些理论依据，在真正实践过程中，可能会遇到各种问题，各种坑，有了理论的支持，我相信可以用技术手段去解决，接下来的sdk文章，我会通过一个如何设计一个优雅的第三方登录sdk来实践上面的理论。敬请期待…… 最近访客","tags":[{"name":"sdk","slug":"sdk","permalink":"http://www.jackway.cn/tags/sdk/"}]},{"title":"jvm-(heap-gc)","date":"2017-01-11T13:45:17.000Z","path":"2017/01/11/jvm-heap/","text":"前面几篇文章我们大体了解到了，jvm运行时内存的布局，class的加载，以及class的验证，这些都是我们虚拟机平台最为核心的功能，其实虚拟机是一个很庞大的系统，里面每个子系统都很重要，如果我们需要对jvm进行一些行为控制，那么我们必须好好理解，那么这篇文章，我来分析一下，jvm里面的堆以及gc，前面也说过，堆内存的重要性，堆与我们开发非常密切，如果在写程序的过程中，没有很好的利用堆内存，最为常见的问题就是内存泄漏，内存溢出等致命bug。下面我来详细分析一下jvm里面的堆与gc。 gc分代理论大部分JVM都会采用所谓的分代收集方式去回收垃圾，什么是分代收集呢？根据对象的存活周期的不同将内存划分为好几块。一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。新生代中，每次垃圾收集时都发现大批对象死去，只有少量存活，那就选用复制算法。老年代因为对象存活率高，没有额外空间对它进行分配担保，那就必须使用“标记-清理”或者“标记-整理”等重量级算法来进行回收。 单纯从JVM的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是优化垃圾回收的性能。更具体的说，把堆划分为新生代和老年代有两个好处： 简化了新对象的分配（只在新生代分配内存）； 可以更有效的清除不再需要的对象（即死对象，新生代和老年代使用不同的回收算法）。 通过广泛研究面向对象实现的应用，发现一些特点：1.大部分对象的生存时间都很短；2.新生对象很少引用生存时间长的对象。所以，新生代通过复制算法可以高效的回收垃圾。 堆区 jvm-heap gc回收过程首先堆可以划分为新生代和老年代，然后新生代又可以划分为一个Elden区和两个Survivor（幸存）区。按照规定，新对象会首先分配在Eden中（如果对象过大，比如大数组，将会直接放到老年代）。在GC中，Eden中的对象会被移动到survivor中，直至对象满足一定的年纪（定义为熬过minor GC的次数），会被移动到老年代。 新生代采取复制算法，在Minor GC之前，to survivor区域保持清空，对象保存在Eden和from survivor区，minor GC运行时，Eden中的幸存对象会被复制到to Survivor（同时对象年龄会增加1）。而from survivor区中的幸存对象会考虑对象年龄，如果年龄没达到阈值，对象依然复制到to survivor中。如果对象达到阈值那么将被移到老年代。复制阶段完成后，Eden和From幸存区中只保存死对象，可以视为清空。如果在复制过程中to幸存区被填满了，剩余的对象将被放到老年代。最后，From survivor和to survivor会调换一下名字，下次Minor GC时，To survivor变为From Survivor。 jvm-heap 总结总结一下，对象一般出生在Eden区，年轻代GC过程中，对象在2个幸存区之间移动，如果对象活到适当的年龄，会被移到老年代。当对象在老年代中死亡时，就需要更高级别的GC，更重量级的GC算法。 注意调优的重要性：新生代的大小设置非常重要，如果新生代过小，会导致新生对象很快就晋升到老年代中，在老年代中对象很难被回收。如果新生代过大，会发生过多的复制过程。因而我们需要找到一个合适的大小，不幸的是，要想获得一个合适的大小，只能通过不断的测试调优，这就需要JVM参数了。下面列出一些调优参数。 调优参数堆设置-Xmx3550m：设置JVM最大堆内存 为3550M。-Xms3550m：设置JVM初始堆内存 为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。-Xss128k： 设置每个线程的栈 大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能 生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。-Xmn2g：设置堆内存年轻代 大小为2G。整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。-XX:PermSize=256M：设置堆内存持久代 初始值为256M。(貌似是Eclipse等IDE的初始化参数)-XX:MaxNewSize=size：新生成的对象能占用内存的最大值。-XX:MaxPermSize=512M：设置持久代最大值为512M。-XX:NewRatio=4：设置堆内存年轻代（包括Eden和两个Survivor区）与堆内存年老代的比值（除去持久代） 。设置为4，则年轻代所占与年老代所占的比值为1:4。-XX:SurvivorRatio=4： 设置堆内存年轻代中Eden区与Survivor区大小的比值 。设置为4，则两个Survivor区（JVM堆内存年轻代中默认有2个Survivor区）与一个Eden区的比值为2:4，一个Survivor区占 整个年轻代的1/6。-XX:MaxTenuringThreshold=7：表示一个对象如果在救助空间（Survivor区）移动7次还没有被回收就放入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于年老代比较多的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代即被回收的概率。回收器选择JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。串行收集器-XX:+UseSerialGC：设置串行收集器并行收集器(吞吐量优先)-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒），如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等。此参数建议使用并行收集器时，一直打开。并发收集器(响应时间优先)-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。CMS， 全称Concurrent Low Pause Collector，是jdk1.4后期版本开始引入的新gc算法，在jdk5和jdk6中得到了进一步改进，它的主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用。CMS是用于对tenured generation的回收，也就是年老代的回收，目标是尽量减少应用的暂停时间，减少FullGC发生的几率，利用和应用程序线程并发的垃圾回收线程来 标记清除年老代。-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了。所以，此时年轻代大小最好用-Xmn设置。-XX:CMSFullGCsBeforeCompaction=：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此参数设置运行次FullGC以后对内存空间进行压缩、整理。-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除内存碎片。-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。-XX:CMSInitiatingOccupancyFraction=70：表示年老代空间到70%时就开始执行CMS，确保年老代有足够的空间接纳来自年轻代的对象。注：如果使用 throughput collector 和 concurrent low pause collector 这两种垃圾收集器，需要适当的挺高内存大小，为多线程做准备。其它-XX:+ScavengeBeforeFullGC：新生代GC优先于Full GC执行。-XX:-DisableExplicitGC：禁止调用System.gc()，但JVM的gc仍然有效。-XX:+MaxFDLimit：最大化文件描述符的数量限制。-XX:+UseThreadPriorities：启用本地线程优先级API，即使 java.lang.Thread.setPriority() 生效，反之无效。-XX:SoftRefLRUPolicyMSPerMB=0：“软引用”的对象在最后一次被访问后能存活0毫秒（默认为1秒）。-XX:TargetSurvivorRatio=90：允许90%的Survivor空间被占用（默认为50%）。提高对于Survivor的使用率——超过就会尝试垃圾回收。辅助信息-XX:-CITime：打印消耗在JIT编译的时间-XX:ErrorFile=./hs_err_pid.log：保存错误日志或者数据到指定文件中-XX:-ExtendedDTraceProbes：开启solaris特有的dtrace探针-XX:HeapDumpPath=./java_pid.hprof：指定导出堆信息时的路径或文件名-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时导出此时堆中相关信息-XX:OnError=”;”：出现致命ERROR之后运行自定义命令-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令-XX:-PrintClassHistogram：遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同-XX:-PrintConcurrentLocks：遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同-XX:-PrintCommandLineFlags：打印在命令行中出现过的标记-XX:-PrintCompilation：当一个方法被编译时打印相关信息-XX:-PrintGC：每次GC时打印相关信息-XX:-PrintGC Details：每次GC时打印详细信息-XX:-PrintGCTimeStamps：打印每次GC的时间戳-XX:-TraceClassLoading：跟踪类的加载信息-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息-XX:-TraceClassResolution：跟踪常量池-XX:-TraceClassUnloading：跟踪类的卸载信息-XX:-TraceLoaderConstraints：跟踪类加载器约束的相关信息JVM服务调优实战服务器：8 cup, 8G meme.g.java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0调优方案：-Xmx5g：设置JVM最大可用内存为5G。-Xms5g：设置JVM初始内存为5G。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。-Xmn2g：设置年轻代大小为2G。整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。-XX:+UseParNewGC：设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。-XX:ParallelGCThreads=8：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。-XX:SurvivorRatio=6：设置年轻代中Eden区与Survivor区的大小比值。根据经验设置为6，则两个Survivor区与一个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。-XX:MaxTenuringThreshold=30： 设置垃圾最大年龄（次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值 设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。设置为30表示 一个对象如果在Survivor空间移动30次还没有被回收就放入年老代。-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试配置这个参数以后，参数-XX:NewRatio=4就失效了，所以，此时年轻代大小最好用-Xmn设置，因此这个参数不建议使用。参考资料 - JVM堆内存的分代虚 拟机的堆内存共划分为三个代：年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集器要收集的Java对象关系不大。所以，年轻代和年老代的划分才是对垃圾 收集影响比较大的。年轻代所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满 时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存 活的对象，将被复制“年老区(Tenured)”。需要注意，两个Survivor区是对称的，没先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个 Survivor区复制过来的对象；而复制到年老区的只有从前一个Survivor区（相对的）过来的对象。而且，Survivor区总有一个是空的。特 殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。年老代在年轻代中经历了N（可配置）次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。持久代用于存放静态数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些Class，例如 Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。持久代大小通过 -XX:MaxPermSize= 进行设置。 了解jvm理论对我们编码，以及目前很火的技术，热修复，插件化，动态部署，都非常有指导性作用，如果想进阶的，一定要好好学习jvm知识，才能做到得心应手，不然后面会遇到很多难点，jvm已经分析几篇与我们开发最为密切的系列，我们对jvm有了基本的认识，我们还不了解jvm的字节码文件，但是很多情况下，我们只需要了解class的基本构成就行，但是在一些场景不行，比如我最近在用asm技术实现hook，那么需要对字节码指令，以及文件构成有深入了解。下篇class结构分析，敬请期待…… 最近访客","tags":[{"name":"heap","slug":"heap","permalink":"http://www.jackway.cn/tags/heap/"},{"name":"gc","slug":"gc","permalink":"http://www.jackway.cn/tags/gc/"}]},{"title":"jvm-class加载验证","date":"2017-01-07T09:58:52.000Z","path":"2017/01/07/jvm-class-verify/","text":"java通过所谓的inbox模型保证了其安全性, inbox就是进程之间的隔离，互不干扰，数据安全，运行安全等安全机制，能够保证我们的程序在自身稳定的情况下，不会受到外界环境干扰，而出现进程运行异常，这篇文章从jvm加载class的角度来分析jvm内部安全体系。 话题大纲 类装载器结构； class文件检验器； 内置于java虚拟机（及语言）的安全特性； 安全管理器及java API。 类装载器体系结构 防止恶意代码去干涉善意的代码。这是通过为不同类加载器提供不同的命名空间来实现的，在java虚拟机中，在同一个命名空间内的类可以直接进行交互，而不同的命名空间中类甚至不能觉察彼此的存在，除非显式地提供允许它们交互的机制。 守护了被信任的类库的边界虚拟机通过使用不同的类装载器装载可靠的包和不可靠的包，即所谓的双亲委派模式：在某个特定的类装载器试图以常用方式装载类型之前，它会先默认将这个任务“委派”给它的双亲，这个双亲再依次请求自己的双亲来装载这个类型。这个委派的过程一直向上继续，直到达到启动类加载器（boostrp classloader），如果一个类加载器的双亲类加载器有能力装载这个类型，则这个类加载器返回这个类型，否则这个类装载器试图自己来装载这个类型。java虚拟机只把彼此访问的特殊权限授予由同一个类装载器装载到同一个包中的类型。在允许两个类型之间对包内可见的成员（声明为受保护的或者包访问的成员）进行访问之前，虚拟机不但要确定这两个类型是否属于同一个包，还要确定它们属于同一个运行时包——即它们必须是由同一个类装载器装载的 将代码归入某类（称为保护域），该类确定了代码可以进行哪些操作。 java类加载器体系 classloader class文件检验器和类加载器一起，class文件检验器保证了装载的class文件内容中有正确的内部结构，并且这些class文件相互间协调一致，如果class文件检验器在class文件中发生了问题，它将抛出异常。好的java编译器不应该产生畸形的class文件，但是java虚拟机并不知道某个特定的class文件的来源，所以java虚拟机的实现必须有个class文件检验器，文件检验器可以调用class文件以确保这些定义的类型可以安全的使用。java虚拟机的class文件检验器在字节码执行之前，必须完成大部分检验工作。class文件检验器需要经过四趟独立的扫描来完成其工作。第一趟扫描是在类被装载时进行的，在这次扫描中，class文件检验器检查这个class文件内部结构，以保证它可以被安全地编译。第二和第三趟扫描是在连接过程进行的，在这两次扫描中，class文件检验器确认类型数据遵从java编程语言的语义，包括检验它所包含的所有字节码的完整性，第四趟扫描是在进行动态链接的过程中解析符号引用时进行的，在这次扫描中，class文件检验器确认被引用的类、字段以及方法确实存在。 第一趟扫描：class文件结构检查对每一段被当做类型导入的字节序列，class文件检验器都会确认其是否符合class文件格式。比如是否以魔数0xCAFEBABE开头，主次版本号所代表的的版本是否被当前虚拟机支持等等，第一趟扫描的主要目的就是保证这个字节序列正确地定义了一个新类型，它必须遵从class文件的固定格式，这样它才能被编译成在方法区中的内部数据结构。第二、第三和第四趟扫描是在方法区中由实现决定的数据结构上进行的。 第二趟扫描：类型数据的语义检查检验一些java语言应该在编译时遵守的强制规则。比如除了Object外，所有类必须有一个父类，final类没有被子类化，常量池中的条目是合法的，而且常量池中的所有索引都指向了正确类型的常量池条目. 第三趟扫描：字节码验证在这趟扫描中，java虚拟机对字节流进行数据流分析，这些字节流代表的是类的方法。它确保局部变量在赋值之前不可访问，类的字段中总必须赋予正确类型的值等等。 第四趟扫描：符号引用验证在动态链接的过程中，如果包含在一个class文件中的符号引用被解析时，class文件检验器将进行第四趟检查。在这趟检查中，java虚拟机将追踪那些引用，从被验证的class文件到被引用的class文件，确保这个引用是正确的。 class检验模型 class-verify java虚拟机中内置的安全特性java虚拟机装载了一个类，并且对它进行了第一到第三趟的class文件检验，这些字节码就可以被运行了。除了对符号引用的检验（class文件检查的第四趟扫描），java虚拟机在执行字节码时还进行了一些内置的安全机制的操作。这些机制大多数是java类型安全的基础： 类型安全的引用转换； 结构化的内存访问（无指针算法）； 自动垃圾收集； 数组边界检查； 空引用检查。内置在java虚拟机中的另一个安全特性,并未指明运行时数据空间在java虚拟机内部分布式怎样的。如果查看class文件的内部，将看不到任何内存地址（全是符号引用和无符号数），当java虚拟机装载一个class文件是，由它决定将这些字节码以及其他从class文件中解析得到的数据放置在内存的什么地方。当虚拟机启动一个线程时，由它决定将这个线程创建java栈放到哪里。最后，java虚拟机拥有异常的结构化错误处理机制，因为java虚拟机支持异常，所以当一些违反安全的行为发生时，它会做一些结构化处理，java虚拟机将抛出一个异常或者错误，而不是崩溃。安全管理器和java API安全管理器定义了沙箱的外部边界，保护虚拟机的外部资源不被虚拟机内运行的恶意或者有漏洞的代码侵犯。javaAPI在进行一个可能不安全的操作前，总是会检查安全管理器，所以javaAPI不会在安全管理器建立的安全策略下执行被禁止的操作。具体可以参考java.lang.SecurityManager类。 最近访客","tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.jackway.cn/tags/jvm/"},{"name":"class-verify","slug":"class-verify","permalink":"http://www.jackway.cn/tags/class-verify/"},{"name":"inbox","slug":"inbox","permalink":"http://www.jackway.cn/tags/inbox/"},{"name":"security","slug":"security","permalink":"http://www.jackway.cn/tags/security/"}]},{"title":"jvm-class生命周期","date":"2017-01-04T09:06:02.000Z","path":"2017/01/04/jvm-classloader/","text":"在class文件中描述的各种信息，最终都需要被加载到虚拟机中之后，才能被运行和使用。虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。 class生死大纲 类加载的时机 类加载过程 验证 准备 解析 初始化 使用 卸载 java classloader 模型,注意不是android的模型 类加载的时机：类从被加载到虚拟机内存开始，到卸载出内存为止，其生命周期包括：加载（loading），验证（verification），准备(preparation)，解析(resolution)，初始化(initialization)，使用(using)，卸载（unloading）。需要对类进行初始化的情况：1.遇到new,jni new,jestatic,putstatic,invokestatic这四条字节码指令。场景：使用new关键字实例化对象，读取或设置一个类的静态字段，调用一个类的静态方法2.使用java.lang.Reflect包的方法对类进行反射调用时。3.当初始化一个类的时候，如果发现其父类还没有进行过初始化。4.当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。一般是main方法，后面详细分析。 类加载过程：加载：1.通过一个类的全限定名来获取定义此类的二进制字节流。这里可以是本地的或者网络的都可以。2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构3.在java堆中生成代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。验证：具体包括1.文件格式验证；2.元数据验证；3.字节码验证；4.符号引用验证； 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区进行分配。注意：这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将在对象实例化的时候随着对象的实例一起被分配到java堆中。 解析：虚拟机将常量池内的符号引用替换为直接引用的过程，不转换是不能使用的，因为javac是静态的，并不知道运行代码，数据分配的内存分配。 初始化：到初始化阶段，才真正开始执行类中定义的java程序代码 使用这个阶段就是真正的运行我们的逻辑，模拟真实世界。 卸载这个一般触发的条件很难，基本不会卸载，一但define了，也就是有些热修复方案为什么要重启app的原因，这里不展开细节，后面专门讲解。卸载必须满足的条件 加载该类的类加载器销毁了，注意namespace的影响 所有基于该类的对象销毁了 Class对象销毁了 java classloader 模型 classloader 注意这里只是java的基本流程，但是我们知道android是没法运行class文件的，必须dx化，转换成dalvik或者art，或者混合模式下的字节码，才能运行。并且移动设备对class的执行进行了深度优化，比如inline等等。这篇只讲解jvm的加载，android的加载必须单独分开写，才能明白原理与区别，后续更新…… 最近访客","tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.jackway.cn/tags/jvm/"},{"name":"class","slug":"class","permalink":"http://www.jackway.cn/tags/class/"}]},{"title":"jvm-内存模型","date":"2017-01-03T09:44:30.000Z","path":"2017/01/03/jvm-memorymodel/","text":"世界是一个很现实的空间，但是我们写的代码运行在一个虚拟的空间，我们知道这个虚拟空间就是虚拟机内部为我们代码运行分配的一个空间，但是这个空间的特性就是规则，也就是说每块区域的职责很明确，下面就揭开虚拟机内存内幕，内存布局是作为了解，学习，虚拟机的最为重要的部分。这篇主要让大家对内存布局有个清晰的认识。 运行数据内存布局 memory 虚拟机栈区 stack 虚拟机变量表 local 虚拟机栈对象引用方式 reference1 reference2 虚拟内存布局还有一个堆区，这个在这里没有画出来，因为堆区比较特殊，非常重要，对于我们理解整个虚拟机内幕都很重要，那个区域必须详细讲解，必须写一篇文章来专门讲解堆区的细节。有了内存布局的认识，下面对jvm gc,class结构，class布局，class加载安全机制，class加载流程，class优化，classloader namespace，classloader模式，class生成细节，字节码指令运用等一些列进行深入分析，敬请期待…… 最近访客","tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.jackway.cn/tags/jvm/"}]},{"title":"总结过去,展望未来,致敬2016","date":"2016-12-30T13:37:24.000Z","path":"2016/12/30/2016总结/","text":"2016即将过去，此时我在想，我该写点什么好了，我该怎么总结自己这一年中的得与失了，我该怎么计划2017了，我该如何计划自己的未来了，我离自己的职业规划的目标还差多远了，那么此文不聊技术，总结自我一下。希望看到此文的同仁也会有自己的感受，也希望同仁对自己也好好的总结。 话题 工作 学习 目标 规划 生活 工作其实我的工作跟简单，从14年7月份毕业到现在差不多2年半一直从事android开发，也是一名普通搬砖的开发人员，在国内还算不上工程师，只能说是一个码农，但是回想毕业到现在，从自己很迷茫到走到现在，个人还是很满足的，虽然还没有到大牛那种级别，但是自己找到了方向，明白了自己在技术这条路上该如何走下去，培养了自己的分析问题，解决问题的实战能力，能够从一些技术层面进行选型，一定层度做到了不仅仅会技术，还做到了技术运用场景的利弊，我个人认为技术只是工作，我们更要培养对技术的认知思维，一切以解决问题为核心驱动技术。作为一名开发人员，首先我们的首要目标是完成任务，不仅仅是量的完成，还要做到质的完成，我个人一般写代码的规则是，首先找到一种方式去实现，然后再去思考又没有更优的方式，然后再去想如何优化现有方式，然后自我测试一下代码，做到心中有底。当然这个过程需要坚持，最开始开发也是以完成任务为最终目标，也不会去管代码的质量，性能如何，只要能够很好的跑起来就好，其实随着你对工作的深刻认识，对业务的认识，对自己技术提升的认识，会觉得自己目前做的事情很无聊，太简单，不想写业务，不想画界面。其实不然，其实这时候需要冷静下来好好的思考一下，自己的内功如何，我是真正的理解了工作的本质吗？我真正理解了业务的流程吗？真正保证程序的稳定性吗？现在代码是否会有缺陷，是否会有潜在的bug出现，只要这么一思考，其实很多心理都没底，其实也就是工作的质量没做到位。周而复始可能会出现dead cycle, 感叹技术怎么提升这么慢，自己也看了不少东西，为什么没有场景去运用了。其实在此时，既是一种机会，也是一种挑战，机会就是在此刻，说明技术在过度，需要提高一个级别了，挑战就是我们需要学习更多的知识，硬技能，软技能，横向思维，团队合作精神，自我管理能力要更加加强。这个过程说起来很简单，其实是非常难的，但是只要突破了这个坎，我想基本上技术肯定会提高一个级别，同时自己的身价也会能提高一个级别，这个只是从技术开发待遇的角度来判定，其他行业就不一定了。毕竟我不知道其他行业的行情。工作归工作，我们打工的目标不是仅仅为了工作，不仅仅是为了公司，不仅仅是为了把公司的业务做的很好，但是前提是，作为一个从业人员，最低标准就是要标准自己负责的工作做好，同时有耦合的工作也要做好，不管什么原因，不管什么理由，只有有了前提保证，我们才能去做自己的事情，工作其实很大程度上不能提高自己的技术深度，只能提高自己对业务的理解，实践，团队配合能力，但是这个很重要，只埋头搞技术的开发人员，除了那种世界顶级的大神，一般的人还是很难成为这样的人的，所以我们工作做好，然后在空闲时间还是要提高自己的对一个技术的深度，现在是互联网时代，很多资料查询参考，也可以通过群交流，技术线下分享等渠道获得很多技术。要整理自己的整体性思维，最好将自己的思维锻炼成3段模型，结构，模型，高速公路，这是高效学习一本书里面的概论，我个人觉得很适合从事开发的人员，只有这样我们才能学的块，学的好，独立解决问题的能力才能提高很快，才能在现有开发团队里面突破自己。工作远远不止这些，但是也不可能就一个总结写的很全，只能做到工作的基本总结，然后自己领悟。 学习其实对于开发而言，活到老学到老真的一点不为过，前提是你想在这个行业有所成就。对自己有期望值，如果你仅仅想养家糊口的那种，那也就没必要谈什么学习了，一般这种人也就是应付工作那种，只要完成工作任务就行。但是换个角度我们看到，这些人几年之后都是边缘化的那种人，那些对自己有期望值的人，生活很滋润，待遇也是非常不错的。那么我们该如何学习了，首先不要盲目学习，所谓的忙学习就是看到技术就学习。其实这样下来，自己的时间浪费在学习上，为什么说浪费了，其实我们根本不知道自己真正需要什么，我们需要解决什么问题，我们需要积累什么，学习的是否对我们的工作有所帮助。所以我们在学习一门技术之前，一定要确认了那些问题，然后才去制定计划学习，一般学习都是一个过程化的，也就是有个过渡。最开始我们学习的都是基础语法，基本程序结构，基本语法特性，如果是面向对象的，需要学习一下对象思维，然后就是基础算法，数据结构，做到这些，基本上就可以将该技术作用到自己想要的地方了，不至于技术无用处。我是android开发的首选语言是java，其实我个人对语言不太默守，也就是说，我始终认为语言仅仅是一个解决特定问题，特定业务的工作，一种手段，只要理解语言的基本特性，基础语法，算法，数据结构，android还要涉及到平台特性，具备这些完全可以写好代码了。不要局限语言思维，要能够将语言技能发散，也就是说要将一种语言思维作用到全部语言，在短时间内，要做到学习一门新语言，并且能够很快的运用到工作中，解决实际问题。这些仅仅是从运用的角度思考，如何要提高代码的质量，那么我们必须学习语言的核心特性，比如写java代码，必须了解jvm特性，编译器特性等等，如果写jni代码，那我们必须了解android平台是如何对so库如何处理的，so代码的运行空间与虚拟机的运行空间的本质区别，以及联系。要真正让自己的代码可控。不要让代码自我毁灭。当然这个需要时间积累，这个也需要学习很多基础知识。学习基础很重要，不管一个框架，一个系统多么的伟大，其实背后都是很多基础技术的叠加，所以我们务必学习基础技能，提炼自己内功，这样才能走的更远，走的更好。学习归学习，不仅仅为了学习而学习，需要不断学习，思考，实践，要让这3个要素良性循环，才能有很好的效果。同时要总结自己走过的坑，这样不仅仅是为了自己，同时分享给大家自己也是一种进步。 目标每个人从事技术行业的目标都不太一样，其实我从事这个行业很简单，就是学习基础技术，提高自己的技术能力，然后能够用技术的手段，解决真正的需求。如果有机会，更希望用技术的手段，改变世界。就如google这样的如此伟大的公司，做到了真正改变世界，不得不佩服，由此像gogole大佬致敬。 规划规划其实也是一种对自己职业生涯的计划，虽然计划赶不上变化，但是我们还是要量化一下自己。不然道路越走越迷茫，最后可能迷失自己，自己还不知道。这样是很危险的。对于我而言，我的规划是1-3年是技术积累，技术深度，广度提高。3-5年技术更进一步的提高与突破，希望在某一个领域有所自己的成就，提高自己的管理能力，不管是技术团队管理能力，还是非技术管理，但是这些前提是要有合适的机会与平台。5-10年希望从未某个领域的专家，能够用已有的积累，做自己喜欢的事情，能够用技术解决社会问题，改善已有的现状。能够有自己的事业平台，同时希望能够提供更大的平台给希望在这个行业发展的伙伴。 生活工作归工作，生活归生活，其实这两者并不冲突，只是我们有时会把这个两者模糊化，其实也是有一定理由的。生活其实也是一种运营，类似公司里面运营人员对产品的运营。如果运营不好，那么很危险。公司还好，运营不好可用比较简单的改变，但是一个人的生活，如果运营不好，就很难改变了。在保证自己技术，学习都具备条件的情况下，还要注重自己的生活，自己的圈子，万物互联，才能走的更远。 总结只是对过去的一种简单描述，其实还有很多说不完的，一篇文章也不可能说清楚，即使说清楚了，也未必对阅读者有意，毕竟不同人的经历不同，在过去走过的路都不一样。体会感受也不一样。这里只是我的一点点感受。希望大家都总结自己的过去。2016真的很快就要离我们而去，接下来，我们需要规划2017，希望明年的今天，我们会有更过的精彩描述，最后提前祝大家元旦快乐，新年快乐，幸福满满，新的一年里有很多美好的奇迹发生在你的身上。共勉…… 最近访客","tags":[{"name":"summary","slug":"summary","permalink":"http://www.jackway.cn/tags/summary/"}]},{"title":"android脑图","date":"2016-12-28T02:44:14.000Z","path":"2016/12/28/android-system-img/","text":"往往文本不那么直观，也让那些不喜欢看文字的大佬们比较疲劳，所以一般我们都会用图片替代文本，即使是文本我们通过一些手段将其转换成图片，那么我们是开发人员，是不是必须跟代码打交代了，有时想理解一些框架原理，我们就不得不去看底层源码，但是我有一种感受就是看懂源码容易，但是过一段时间我就会忘记，我认为记不久的根本原因就是没有在脑袋形成一幅风景，所以就有了今天的android系统中，包括编译,打包,运行时,框架,安装等脑图。 compile build-ant build-detail build-gradle build-official install application-framework activity-data-transfer activity-fragment-lifecycle activity-lifecycle-2 activity-lifecycle fragment-lifecycle service-lifecycle ui-action-down-dispatch view-widgets-inherit system-framework framework handler-sequence.jpg 后续会不断整理脑图….. 最近访客","tags":[{"name":"xmind","slug":"xmind","permalink":"http://www.jackway.cn/tags/xmind/"},{"name":"android-sys-img","slug":"android-sys-img","permalink":"http://www.jackway.cn/tags/android-sys-img/"}]},{"title":"JMM-transient","date":"2016-12-25T04:01:41.000Z","path":"2016/12/25/JMM-transient-4/","text":"java里面将一个对象序列化，步骤就是将要被序列化的对象实现Serializable接口，这个接口是个标志接口，跟java里面的Clonable,Closable等接口一样，没有具体的行为标准定义，就是一个描述。只有实现了序列化接口的对象，才能够序列化，但是我们还注意到序列化对象的类的内部还定义了一个serialVersionUUID,这个是做什么的了，这个可以理解为一个token，只有token值一样的类，序列化的对象才可逆，也就是说，标志这个class,Class对象是否前后版本一致。注意类里面的被序列的数据只有，非static字段，非transient字段。下面重点来来讲解序列化的几种不同姿势。以及我们需要的地方，但是在Android里面最好用Parcelable接口，实现数据的序列化，这个本地性能很棒，原因是内存拷贝，前者是反射，性能当然差点哈，但是如果要将对象在网络传输，那么我们就只能用前者了。其实还有一个接口可以实现序列化，本文为了更专注序列化的几大特性来讲，不会过多介绍，后面我会提到。知道就行。 序列化5点那点事 序列化允许重构 序列化并不安全 序列化的数据可以被签名和密封 序列化允许将代理放在流中 信任，但要验证 Parcelable 上面5点中主要还是数据安全，跟安全那点事情这篇文章的理论接轨，如果对数据安全不是很理解的，可以看看这篇文章，有个理论基础，然后再具体代码。其实代码不难，主要是这种解决问题的组合。 演示基础类123456789101112131415161718192021222324252627282930313233public class Person implements java.io.Serializable&#123; public Person(String fn, String ln, int a) &#123; this.firstName = fn; this.lastName = ln; this.age = a; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getAge() &#123; return age; &#125; public Person getSpouse() &#123; return spouse; &#125; public void setFirstName(String value) &#123; firstName = value; &#125; public void setLastName(String value) &#123; lastName = value; &#125; public void setAge(int value) &#123; age = value; &#125; public void setSpouse(Person value) &#123; spouse = value; &#125; public String toString() &#123; return \"[Person: firstName=\" + firstName + \" lastName=\" + lastName + \" age=\" + age + \" spouse=\" + spouse.getFirstName() + \"]\"; &#125; private String firstName; private String lastName; private int age; private Person spouse;&#125; 序列化允许重构序列化允许一定数量的类变种，甚至重构之后也是如此，ObjectInputStream 还是可以很好的将其读出来。Java Object Serialization 规范可以自动管理的关键任务是： 将新字段添加到类中 将字段从 static 改为非 static 将字段从 transient 改为非 transient 1234567891011121314151617181920212223242526272829303132333435363738394041enum Gender&#123; MALE, FEMALE&#125;public class Person implements java.io.Serializable&#123; public Person(String fn, String ln, int a, Gender g) &#123; this.firstName = fn; this.lastName = ln; this.age = a; this.gender = g; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public Gender getGender() &#123; return gender; &#125; public int getAge() &#123; return age; &#125; public Person getSpouse() &#123; return spouse; &#125; public void setFirstName(String value) &#123; firstName = value; &#125; public void setLastName(String value) &#123; lastName = value; &#125; public void setGender(Gender value) &#123; gender = value; &#125; public void setAge(int value) &#123; age = value; &#125; public void setSpouse(Person value) &#123; spouse = value; &#125; public String toString() &#123; return \"[Person: firstName=\" + firstName + \" lastName=\" + lastName + \" gender=\" + gender + \" age=\" + age + \" spouse=\" + spouse.getFirstName() + \"]\"; &#125; private String firstName; private String lastName; private int age; private Person spouse; private Gender gender;&#125; 也就是说保证has值不变的条件下，满足上面的规范，都可以实现类的升级，最常见的就是往类里面添加字段，即使旧版本的类没有这个字段，但是序列化的时候也不会报错，只是没意义对应的值，只有对象的初始化的默认值。基于基础类添加了一个gender字段，序列化，反序列化都是没问题的。 序列化并不安全让 Java 开发人员诧异并感到不快的是，序列化二进制格式完全编写在文档中，并且完全可逆。实际上，只需将二进制序列化流的内容转储到控制台，就足以看清类是什么样子，以及它包含什么内容。这对于安全性有着不良影响。例如，当通过 RMI 进行远程方法调用时，通过连接发送的对象中的任何 private 字段几乎都是以明文的方式出现在套接字流中，这显然容易招致哪怕最简单的安全问题。幸运的是，序列化允许 “hook” 序列化过程，并在序列化之前和反序列化之后保护（或模糊化）字段数据。可以通过在 Serializable 对象上提供一个 writeObject 方法来做到这一点。我们可以重写这几个方法，对字段进行模糊处理，加密，如果是数值，最简单可以进行位元算打乱。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Person implements java.io.Serializable&#123; public Person(String fn, String ln, int a) &#123; this.firstName = fn; this.lastName = ln; this.age = a; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getAge() &#123; return age; &#125; public Person getSpouse() &#123; return spouse; &#125; public void setFirstName(String value) &#123; firstName = value; &#125; public void setLastName(String value) &#123; lastName = value; &#125; public void setAge(int value) &#123; age = value; &#125; public void setSpouse(Person value) &#123; spouse = value; &#125; private void writeObject(java.io.ObjectOutputStream stream) throws java.io.IOException &#123; // \"Encrypt\"/obscure the sensitive data age = age &lt;&lt; 2; stream.defaultWriteObject(); &#125; private void readObject(java.io.ObjectInputStream stream) throws java.io.IOException, ClassNotFoundException &#123; stream.defaultReadObject(); // \"Decrypt\"/de-obscure the sensitive data age = age &gt;&gt; 2; &#125; public String toString() &#123; return \"[Person: firstName=\" + firstName + \" lastName=\" + lastName + \" age=\" + age + \" spouse=\" + (spouse!=null ? spouse.getFirstName() : \"[null]\") + \"]\"; &#125; private String firstName; private String lastName; private int age; private Person spouse;&#125; 上面将敏感数据age进行位运算，这样一定程度可以保证数据安全，但是如果我们代码被反编译了，显然一看就知道我们的规则，我们最好将模糊算法放入jni提高安全性。还有数据运算要保证不要溢出，不然本身数据都不正确了，模糊就没意义了。 序列化的数据可以被签名和密封上一个技巧假设您想模糊化序列化数据，而不是对其加密或者确保它不被修改。当然，通过使用 writeObject 和 readObject 可以实现密码加密和签名管理，但其实还有更好的方式。如果需要对整个对象进行加密和签名，最简单的是将它放在一个 javax.crypto.SealedObject 和/或 java.security.SignedObject 包装器中。两者都是可序列化的，所以将对象包装在 SealedObject 中可以围绕原对象创建一种 “包装盒”。必须有对称密钥才能解密，而且密钥必须单独管理。同样，也可以将 SignedObject 用于数据验证，并且对称密钥也必须单独管理。结合使用这两种对象，便可以轻松地对序列化数据进行密封和签名，而不必强调关于数字签名验证或加密的细节。api的使用自行google就好。使用方法不难。 序列化允许将代理放在流中很多情况下，类中包含一个核心数据元素，通过它可以派生或找到类中的其他字段。在此情况下，没有必要序列化整个对象。可以将字段标记为 transient，但是每当有方法访问一个字段时，类仍然必须显式地产生代码来检查它是否被初始化。如果首要问题是序列化，那么最好指定一个 flyweight 或代理放在流中。为原始 Person 提供一个 writeReplace 方法，可以序列化不同类型的对象来代替它。类似地，如果反序列化期间发现一个 readResolve 方法，那么将调用该方法，将替代对象提供给调用者。打包和解包代理 writeReplace 和 readResolve 方法使 Person 类可以将它的所有数据（或其中的核心数据）打包到一个 PersonProxy 中，将它放入到一个流中，然后在反序列化时再进行解包。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class PersonProxy implements java.io.Serializable&#123; public PersonProxy(Person orig) &#123; data = orig.getFirstName() + \",\" + orig.getLastName() + \",\" + orig.getAge(); if (orig.getSpouse() != null) &#123; Person spouse = orig.getSpouse(); data = data + \",\" + spouse.getFirstName() + \",\" + spouse.getLastName() + \",\" + spouse.getAge(); &#125; &#125; public String data; private Object readResolve() throws java.io.ObjectStreamException &#123; String[] pieces = data.split(\",\"); Person result = new Person(pieces[0], pieces[1], Integer.parseInt(pieces[2])); if (pieces.length &gt; 3) &#123; result.setSpouse(new Person(pieces[3], pieces[4], Integer.parseInt (pieces[5]))); result.getSpouse().setSpouse(result); &#125; return result; &#125;&#125;public class Person implements java.io.Serializable&#123; public Person(String fn, String ln, int a) &#123; this.firstName = fn; this.lastName = ln; this.age = a; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getAge() &#123; return age; &#125; public Person getSpouse() &#123; return spouse; &#125; private Object writeReplace() throws java.io.ObjectStreamException &#123; return new PersonProxy(this); &#125; public void setFirstName(String value) &#123; firstName = value; &#125; public void setLastName(String value) &#123; lastName = value; &#125; public void setAge(int value) &#123; age = value; &#125; public void setSpouse(Person value) &#123; spouse = value; &#125; public String toString() &#123; return \"[Person: firstName=\" + firstName + \" lastName=\" + lastName + \" age=\" + age + \" spouse=\" + spouse.getFirstName() + \"]\"; &#125; private String firstName; private String lastName; private int age; private Person spouse;&#125; 注意，PersonProxy 必须跟踪 Person 的所有数据。这通常意味着代理需要是 Person 的一个内部类，以便能访问 private 字段。有时候，代理还需要追踪其他对象引用并手动序列化它们，例如 Person 的 spouse。这种技巧是少数几种不需要读/写平衡的技巧之一。例如，一个类被重构成另一种类型后的版本可以提供一个 readResolve 方法，以便静默地将被序列化的对象转换成新类型。类似地，它可以采用 writeReplace 方法将旧类序列化成新版本。 信任，但要验证认为序列化流中的数据总是与最初写到流中的数据一致，这没有问题。但是，正如一位美国前总统所说的，“信任，但要验证”。对于序列化的对象，这意味着验证字段，以确保在反序列化之后它们仍具有正确的值，“以防万一”。为此，可以实现 ObjectInputValidation 接口，并覆盖 validateObject() 方法。如果调用该方法时发现某处有错误，则抛出一个 InvalidObjectException。 Parcelable这个我们在组件之间传递对象数据的时候，很常见，比如intent启动一个activity然后带一些数据过去，那么我们就可以传输一个pracelabel对象过去，最开始提到,android里面优先使用这种序列化，在性能，内存等方面的考虑都会优越于java里面的Serializable方式。首先paracelable底层其实是用parcel存储数据，并且这个类也只是一个java层的包装，里面有个很重要的成员变量long类型的native引用，其实我们写数据是写在这个对象上面，这个对象是jni里面的一个对象，用c++实现的一个类Parcel，这里有个很有意思的技术点，就是将c＋＋一个对象转换成基本基本类型，然后存储在java层，这样我们java层拿了这个基本数据值，就很容易的创建出对应的jni对象，然后实现数据读取与存储。google 的这种做法非常牛逼。接下来的jni文章会重点说这种方式的具体实现。 总结序列化其实其实我们想象的那么简单，只是我们使用很简单，但是里面还是很多需要我们去挖掘的，才能深入理解序列化内部，才能很好的使用，出问题可以搞定它。到此java里面的核心关键字分析final,volatile,transient等都分析完了，我个人觉得这是java里面最难理解的，也是最核心的，能够理解这些，并能够很好运用到java代码里面就可以了。后续会计划继续分析java里面核心的技术点，比如线程，线程池，nio，io，集合，网络，gc，jvm的一些核心特性等。一切都输围绕解决实际问题出发。 最近访客","tags":[{"name":"transient","slug":"transient","permalink":"http://www.jackway.cn/tags/transient/"}]},{"title":"安全那点事情","date":"2016-12-22T08:01:43.000Z","path":"2016/12/22/transfer-security-1/","text":"安全重要吗？有必要深度考虑安全吗？什么是安全？这篇文章就这些问题来聊聊安全。就我心目中的安全而言，安全大概包括以下几个方面: 网络数据传输安全，本地数据安全，网络中间劫持，运营商劫持,app反编译，app二次打包，so 调试等,下面我就针对我每个方面的思考详细讲解一下。 网络数据安全数据安全有两层含义:第一层含义就是数据本身是否可见，第二层含义是数据是否被篡改。数据可见也就是最基本的明文传输方式了，判断数据是否被篡改最简单方式生成数据摘要。但是我们仔细思考一下，其实网络数据传输过程中，路径是非常复杂的，通道的安全性，我们很难保证。我们一般的做法就是将传输的数据进行加密，生成摘要，然后传输给目的地。那么问题来了，怎么加密，现在我们一般也是用开源的加密算法进行加密，比如Cipher AES，那么问题又来了，加密需要对应的key，我们可以使用KeyStore生成对应SecretKey然后进行加密，然而这个key是通过别名获取的SecretKey secretKey = (SecretKey) keyStore.getKey(KEY_NAME, null); 那么问题来了，怎么保证alias的安全尤为重要，我们想象一下，我们的加密key来自KeyStore,然而这个key是通过alias获取的，如果我们泄漏了alias那么意味着我们的密钥泄漏了，意味着可以加解密了，意味着我们的加密根本没意义了。显然是不安全的，那么我们怎么解决了？首先我们的目标肯定是要保证key安全，我们要想一切办法保证key安全，有一句话一定要记住，使用开源的加解密算法，那么我们必须保证key安全，如果使用自己的加解密算法，那么要保证自己的算法安全，或者key安全。我们可以这么实现key的安全，我相信很多人会想到把key存到so里面去，确实没错，但是又没有想过，存储必定后面我们会要读取，那么肯定提供了读取的接口，那么也就不安全了，别人拿到对应的so只要调用一下就可以获取到key了，我们再更深入的思考一下，先假设我们的app打包密钥没有泄漏，为什么首先有这个假设了，如果这个都泄漏了，那么我后面的解决方式都没有意义了，但是一般这个都不会去泄漏，安全都是相对的。我假设是一种理想状态，没有泄漏，我们都知道app打包的时候都是需要签名的，我们可以读取到对应的签名值，然后生成摘要，将这个固定值写入so代码里面，然后我们知道jni首次加载初始化的时候，首先会调用JNI_OnLoad这个方法进行初始化操作，那么我们可以在这个里面做认证，判断这个so的使用者是不是我们自己的app，也就在这个方法里面读取一下，我们目前运行app的签名值，然后跟写入so代码里面的值进行比较，如果不一样直接exit(0)。还有一种可能就是这个我们的so可能被调试，这个通过AndroidManifese.xml文件的application标签debuggable＝true 设定就可以调试了，导致调试者可能拿到so里面的值，然后在java层返回一样的值，来欺骗程序，那么怎么避免被调试了，即使调试了，也直接退出程序，同样的在初始化函数里第一行代码加上checkSelfTraced() 来检测是否被调试，具体代码，后面贴出来。其实这个也不难，就是去检测/proc/pid/status里面tracePid的值，如果不为0那么被调试了。然后在JNI_On_UnLoad卸载so资源。这样基本可以做到存储在so里面key的安全，这个方法相当于在接口调用层加了一个认证，保证能够正确调用接口的前提必须满足，不然接口不能正常发起调用。做到key基本安全了，那么我们就可以放心的使用开源的加解密算法了，对数据加密，然后签名。然后在网络传输。这样基本可以保证数据是安全的。 本地数据安全本地数据安全的含义是指，app数据存储在手机里面的数据是否安全，比如我们经常有自动登录的功能，那么就要将密码存储在本地，密码肯定不能明文存储，即使存储到私有目录/data/data/packagename下面，如果root了也是很容易拿到数据的。显然不安全，还有我们登录之后，服务端返回的token，uuid，等令牌，这些也不能明文存储，一但这些数据被其他人拿到，就可以使用服务端接口服务，在有效期了。也是很不安的。可以调用接口，获取对应的数据。那么问题来了，既然已经不安全，那么我们怎么做才能保证安全了，同样的方法利用网络数据安全的思想运用到本地数据安全，用key本地数据进行加密，需要的时候进行解密，加密之后，就可以存储到很多存储介质上了，比如file,sp,db,usb等等，但是目前市面上有的db自带加密功能，也是可以的。但是一样要保证加密key安全。 网络中间劫持网络劫持就是中间人攻击，当我们发起一个网络请求的时候，其实网络环境是很复杂的，可能中间经过路由，交换机，等网络媒体，最后才能到达我们的目的地，那么问题来了，中间的某一个节点都有可能拦截我们请求，然后模拟返回数据给我们。那么问题来了，如果我们客户端没验证这些数据，有时即使验证了，但是是合法的，那么我们就认为数据是我们的伙伴来的，其实不是，但是我们并不知道，这样被欺骗的很厉害，有的同学会说，我们传输的数据不是加密了吗？中间者拿到数据解密不了，还是没用呀，确实，安全是相对的，假设key被泄漏，我们也不知道，那么就可能解密，这也是有可能的。那么怎么避免被劫持了，即使被劫持了，我们怎么才知道这次response是来自我们的好伙伴了。有两种解决方案：第一种如果我们用http请求，那么我们就没用ca认证这一个环节，但是我们可以模拟这个认证，也就是我们跟服务端首先约定一一些规则，一些固定参数，一些算法检验参数的合法性。这样即使中间人即使拿到数据，并且解密了，返回数据的时候，也可以验证对方身份。如果使用https请求，我们可用ca证书认证，或者pin认证都可以识别对方的身份。具体就是将公钥证书存储在本地，然后去认证对方。这样就可以知道自己是否被中间人劫持过。 运营商劫持为什么要将网络劫持和运营商劫持分开来讲解了没，我认为网络劫持还是比较好解决的，但是运营商劫持就不那么好解决。我们有时发现，webview加载一个网页，突然页面底部多了一个广告栏，但是我们js代码根本没这个逻辑，真奇怪。那这个代码怎么来的了，这个就是运营商拦截注入进来的。我们还是用网络中间劫持的解决方式去认证对方身份是不是我们的好伙伴，如果是进行进一步通信。但是这种方式好使吗？我们只能用ssl的方式来避免这种劫持了。 app反编译app反编译现在市面上工具很多，比如jadx,dex2jar,jdui等等，都很容易反编译看到我们的代码，即使混淆了，在一定层度上也可以做到还原，那么问题来了，我们代码就不安全了，一些核心算法也就会盗版掉，通过注入一些广告或者恶意代码，然后二次打包，窃取用户信息，上传到后台。现在市面很多解决方案，比如比较牛叉的就是对apk进行加固。这个原理简单就是在原有apk中套一层壳，在运行的时候脱壳，然后加载。即使反编译其实看到的并不是apk本身代码，做到了apk的保护，但是这个也是相对的。 app二次打包所谓二次打包就是，将已有的apk反编译，然后修改原有apk里面的资源或者代码，再签名进行发布。 so调试so我们知道是c/c++代码生成的二进制文件，这个文件安全性还是很高的，一般很难破解，so调试就是通过运行程序的方式，然后借助第三方工具ida对so进行调试，调试的好处就是能够很清楚的看到内存值，就可以进行对操作进行猜测。如何避免被调试了，一般做法是在so初始化函数加上验证代码。 上面说的都是一些理论，但是理论可以足已解决安全问题，不能说绝对安全，但是安全本身就是相对的。有了理论我们还必须实践，检验理论的正确性。下面给出基本key安全，防止调试的jni，java的部分代码，后面会作为一个基础库开放出来。 jni层代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;jni.h&gt;#include &lt;unistd.h&gt;#include &lt;android/log.h&gt;#include &lt;stdio.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;static const char *kTAG = \"sec\";#define LOGI(...) \\ ((void)__android_log_print(ANDROID_LOG_INFO, kTAG, __VA_ARGS__))#define LOGW(...) \\ ((void)__android_log_print(ANDROID_LOG_WARN, kTAG, __VA_ARGS__))#define LOGE(...) \\ ((void)__android_log_print(ANDROID_LOG_ERROR, kTAG, __VA_ARGS__))const char *KEY = \"EduigvnRM!@5269yg\";static char *SIGNATURE = \"85C3272D0145DAF5E30C55B387E5CD5B\"; // signature to md5JNIEXPORT jstring ab(JNIEnv *env, jclass clz) &#123; return (*env)-&gt;NewStringUTF(env, KEY);&#125;static JNINativeMethod nativeMethod[] = &#123;&#123;\"key\", \"()Ljava/lang/String;\", (void *) ab&#125;&#125;;static char *CLASSNAME = \"com/longway/key/Key\";static volatile unsigned int run = 1;int getTracePid(char *line) &#123; if (line == NULL) &#123; return -1; &#125; char result[30]; unsigned int count = 0; for (int i = 0; i &lt; strlen(line); i++) &#123; if (count &gt;= 29) &#123; break; &#125; if (*line &gt;= 48 &amp;&amp; *line &lt;= 57) &#123; result[count] = *line; count++; &#125; ++line; &#125; return atoi(result);&#125;void start() &#123; int pid = getpid(); LOGE(\"pid=%d\", pid); char filename[15] = &#123;'\\0'&#125;; sprintf(filename, \"/proc/%d/status\", pid); char line[256] = &#123;'\\0'&#125;; // file line??? unsigned int count = 0; FILE *file; while (run) &#123; count = 0; file = fopen(filename, \"r\"); while (!feof(file)) &#123; fgets(line, 256, file); LOGE(\"line %s\", line); if (count == 5) &#123; int tracePid = getTracePid(line); if (tracePid &gt; 0) &#123; LOGE(\"tracePid=%d,haha self died.\", tracePid); _exit(0); &#125; &#125; ++count; &#125; fclose(file); sleep(5); &#125;&#125;pthread_t pthread;void checkSelfTraced() &#123; int id = pthread_create(&amp;pthread, NULL, start, NULL); if (id != 0) &#123; LOGE(\"create pthread fail, error code %d\", id); &#125;&#125;JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) &#123; checkSelfTraced(); // traced?????? JNIEnv *env; if ((*vm)-&gt;GetEnv(vm, (void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; return JNI_ERR; // JNI version not supported. &#125; jclass clz = (*env)-&gt;FindClass(env, CLASSNAME); if (clz == NULL) &#123; return JNI_ERR; &#125; if ((*env)-&gt;RegisterNatives(env, clz, nativeMethod, sizeof(nativeMethod) / sizeof(nativeMethod[0])) &lt; 0) &#123; LOGE(\"register native method fail.\"); return JNI_ERR; &#125; if (env == NULL) &#123; return JNI_ERR; &#125; jmethodID method = (*env)-&gt;GetStaticMethodID(env, clz, \"getSignature\", \"()Ljava/lang/String;\"); if (method == NULL) &#123; return JNI_ERR; &#125; jstring result = (*env)-&gt;CallStaticObjectMethod(env, clz, method); const char *host = (*env)-&gt;GetStringUTFChars(env, result, NULL); LOGE(\"signature:%s\", host); if (strcmp(host, SIGNATURE) != 0) &#123; LOGE(\"haha self died.\"); _exit(0); &#125; LOGE(\"verify success.\"); return JNI_VERSION_1_6;&#125;void JNI_OnUnLoad(JavaVM *javaVM, void *reserved) &#123; pthread_detach(pthread); // detach pthread run = 0; // stop java层代码12345678910111213141516171819public class Key &#123; private static final String TAG = \"key\"; static &#123; Log.e(TAG, \"start load......\"); try &#123; System.loadLibrary(\"key\"); &#125;catch (UnsatisfiedLinkError error)&#123; error.printStackTrace(); &#125; &#125; public native static String key(); // native call public static String getSignature() &#123; return AppUtils.getHostSignature(SystemServiceManager.getAppContext()); &#125;&#125; 代码不难理解，对代码有疑问的可以评论提出疑问。后面将会发布工程代码，敬请期待…… 总结安全其实还是很多事情需要我们思考，我们需要不断的防范，才能对应一些攻击，安全与黑客永远都是对手，但是我相信，我们从自己的防范做起，还是可以拦截那些攻击者的。 最近访客","tags":[{"name":"security","slug":"security","permalink":"http://www.jackway.cn/tags/security/"},{"name":"attack","slug":"attack","permalink":"http://www.jackway.cn/tags/attack/"}]},{"title":"AccessibilityService(自动化服务)?","date":"2016-12-20T10:24:57.000Z","path":"2016/12/20/accessibilityService-1/","text":"AccessibilityService是android系统提供的一种辅助服务，google设计这个玩意我想初心肯定是为了提供更加便捷的服务，但是同时也提供了很多创新的姿势，这篇文章主要讲解一下辅助自动安装，首先要声明的是不是静默安装，这个肯定是从入门到放弃，不信可以试试。至于为什么，自己去看PackageManager这一系列的源码就知道了。 AccessibilityService 创建步骤创建一个类继承AccessibilityService 然后重写抽象方法12public void onAccessibilityEvent(AccessibilityEvent event)public void onInterrupt() 其实我们最关系的是第一个抽象方法的，通过拿到AccessibilityEvent这个包装类我们可以做很多事情，比如通过事件类型，包名，事件动作，事件类型做处理。 简单代码片段:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class AutoService extends AccessibilityService &#123; private static final String[] FILTER = &#123;\"下一步\", \"安装\", \"打开\", \"Next\", \"Install\", \"Open\"&#125;; private static final String[] ACCEPT_PACKAGENAME = &#123;\"com.android.packageinstaller\"&#125;; private final boolean acceptPackageName(CharSequence packagename) &#123; for (String pn : ACCEPT_PACKAGENAME) &#123; if (TextUtils.equals(packagename, pn)) &#123; return true; &#125; &#125; return false; &#125; private final boolean acceptEventType(int eventType) &#123; if (eventType != AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED &amp;&amp; eventType != AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED &amp;&amp; eventType != AccessibilityEvent.TYPE_VIEW_CLICKED) &#123; return false; &#125; return true; &#125; @Override public void onAccessibilityEvent(AccessibilityEvent event) &#123; Log.e(\"event\", event.toString()); CharSequence packageName = event.getPackageName(); if (!acceptPackageName(packageName)) &#123; return; &#125; if (!acceptEventType(event.getEventType())) &#123; return; &#125; //AccessibilityNodeInfo accessibilityNodeInfo = event.getSource(); AccessibilityNodeInfo accessibilityNodeInfo = getRootInActiveWindow(); if (accessibilityNodeInfo == null) &#123; return; &#125; for (String label : FILTER) &#123; List&lt;AccessibilityNodeInfo&gt; accessibilityNodeInfos = accessibilityNodeInfo.findAccessibilityNodeInfosByText(label); if (accessibilityNodeInfos == null) &#123; continue; &#125; for (AccessibilityNodeInfo nodeInfo : accessibilityNodeInfos) &#123; if (nodeInfo.isClickable() &amp;&amp; nodeInfo.isEnabled()) &#123; nodeInfo.performAction(AccessibilityNodeInfo.ACTION_CLICK); &#125; &#125; &#125; &#125; @Override public void onInterrupt() &#123; &#125;&#125; 定义xml配置信息在res/xml/accessibilityservice.xml 写如下内容:12345678910&lt;accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\" android:accessibilityEventTypes=\"typeWindowStateChanged|typeWindowContentChanged|typeViewClicked\" android:accessibilityFeedbackType=\"feedbackVisual\" android:notificationTimeout=\"100\" android:accessibilityFlags=\"flagDefault\" android:canRetrieveWindowContent=\"true\" android:description=\"@string/auto_install\" android:canRequestTouchExplorationMode=\"true\" &gt;&lt;/accessibility-service&gt; 具体属性含义可以去开发者官网查阅，现在也不用翻墙了，最好就不要百度了。 在AndroidManifest注册服务1234567&lt;service android:name=\".AutoService\" android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=\"android.accessibilityservice\" android:resource=\"@xml/accessibilityservice\" /&gt; &lt;/service&gt; 这样辅助服务的流程就结束，最后记住安装之后，还要在手机里打开对应的辅助服务，才能看到效果。 辅助服务的流程都一样，通过这种手段可以实现很多有意思的功能，我认为这个服务有点类似脚本，可以自动化的执行一些动作，比如微信自动抢红包，语音播放 等等都可以通过这种实现，其实只要系统提供了相应事件的，我们都可以基于这些事件做一些事情。后续更丰富…… 最近访客","tags":[{"name":"Service","slug":"Service","permalink":"http://www.jackway.cn/tags/Service/"},{"name":"AccessibilityEvent","slug":"AccessibilityEvent","permalink":"http://www.jackway.cn/tags/AccessibilityEvent/"}]},{"title":"JMM-final","date":"2016-12-18T04:34:36.000Z","path":"2016/12/18/JMM-3/","text":"Java内部类final语义实现 本地临时变量 基本类型 本地临时变量 引用类型 引用字段，基本类型 引用字段，引用类型 引用类型，引用类型，static字段 本地临时变量 基本类型123456789101112131415final int x = 10; new Runnable() &#123; @Override public void run() &#123; System.out.println(x); &#125;&#125;.run(); 12345670: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream;3: bipush 105: invokevirtual #3 // Method java/io/PrintStream.println:(I)V8: return 可以看出，此常量值直接被写在内部类的临时变量中，即相当于进行了一次变量copy。 本地临时变量 引用类型123456789101112131415final T t = new T(); new Runnable() &#123; @Override public void run() &#123; System.out.println(t); &#125;&#125;.run(); 1234567891011121314151617181920212223242526272829303132333435final T val$t; flags: ACC_FINAL, ACC_SYNTHETIC T$1(T); Signature: (LT;)V//构建函数的字节码 0: aload_0 1: aload_1 2: putfield #1 // Field val$t:LT; 5: aload_0 6: invokespecial #2 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: return //main函数字节码 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: getfield #1 // Field val$t:LT; 7: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 10: return 可以看出，这时自动生成了一个带有1个参数的构造函数，并且将相应的t值作为参数传递到内部类当中，同时设定final语义，即不能被内部类修改。 上面的是无参构造函数，如果是一个有参数的内部类呢，如下所示： 1234567891011Thread thread = new Thread(\"thread-1\") &#123;@Override public void run() &#123;System.out.println(t);&#125;&#125;; 123T$1(java.lang.String, T); Signature: (Ljava/lang/String;LT;)V 可以看出，编译器将自动对原来调用的构造函数进行了修改，将原来只需要1个参数的构造函数 修改为传2个参数，并且同时将相应的t传递进去。 引用字段，基本类型12345678910111213141516171819int t = 3; private void xx() &#123; new Runnable() &#123; @Override public void run() &#123; System.out.println(t); &#125; &#125;.run();&#125; 1234567891011121314151617181920212223T$1(T); Signature: (LT;)V flags: Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LT; 5: aload_0 6: invokespecial #2 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: return 这里并没有如临时变量那样，直接在内部类中进行常量定义。为什么？因为这里的t对象随时可能被修改。 引用字段，引用类型12345678910111213141516171819final String t = new String(\"abc\"); private void xx() &#123; new Runnable() &#123; @Override public void run() &#123; System.out.println(t); &#125; &#125;.run();&#125; 123456789101112131415161718192021 final T this$0; Signature: LT; T$1(T);//内部类构造函数 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LT; 5: aload_0 6: invokespecial #2 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: return 这里，在内部类的构造函数中，直接将外部类的this传递进来了，因此在内部类的run方法中，对于t，将直接两层getField进行调用，即可以拿到相应的信息。如下所示： 12345678910110: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: getfield #1 // Field this$0:LT; 7: getfield #4 // Field T.t:Ljava/lang/String;10: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V13: return 引用类型，引用类型，static字段12345678910111213141516171819static String t = new String(\"abc\"); private void xx() &#123;new Runnable() &#123;@Override public void run() &#123;System.out.println(t);&#125;&#125;.run();&#125; 1234567891011121314151617181920212223242526272829303132333435 final T this$0; Signature: LT; flags: ACC_FINAL, ACC_SYNTHETIC T$1(T); Signature: (LT;)V//构造函数字节码 0: aload_0 1: aload_1 2: putfield #1 // Field this$0:LT; 5: aload_0 6: invokespecial #2 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 9: return //run方法字节码 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: getstatic #4 // Field T.t:Ljava/lang/String; 6: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 9: return 可以看出，即使是引用static字段，在内部类中仍然会保留外部类的引用，即达到引用目的。同时，在run方法内部，因为是static字段，因此将不再使用getField，而是使用getStatic来进行相应字段的引用。 总结在整个内部类字节码的生成规则中，主要采用了修改构造函数的方式来将需要在整个内部类中引用的变量进行参数传递。并且，因为是内部类，构造函数是已知的，可以随意的修改。针对特定的场景，可以进行一定的优化，如常量化(临时变量基本类型)。因为在整个JVM层，并没有针对内部类作特殊的处理，因此这些处理手法都是在编译层进行处理的。同时，在语言层，针对这些生成的信息进行指定的说明。如SYNTHETIC语义。在反射字段Member层，定义了如下方法：12345678910111213141516171819/** * Returns &#123;@code true&#125; if this member was introduced by * the compiler; returns &#123;@code false&#125; otherwise. * * @return true if and only if this member was introduced by * the compiler. * @jls 13.1 The Form of a Binary * @since 1.5 */public boolean isSynthetic(); 即此信息是由编译器引入的。了解这些对于整个语言层有一定的理解意义，但并不代表将来这些不会会改变，了解一些实现细节有助于自己在代码实现层有进一步的思考空间，并不局限于之前所了解的信息。 最近访客","tags":[{"name":"final","slug":"final","permalink":"http://www.jackway.cn/tags/final/"},{"name":"bytecode","slug":"bytecode","permalink":"http://www.jackway.cn/tags/bytecode/"}]},{"title":"JMM-volatile","date":"2016-12-18T04:18:57.000Z","path":"2016/12/18/JMM-2/","text":"Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。本文介绍了几种有效使用 volatile 变量的模式，并强调了几种不适合使用 volatile 变量的情形。 volatileVolatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。出于简易性或可伸缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。 正确使用volatile的条件 对变量的写操作不依赖于当前值。 该变量没有包含在具有其他变量的不变式中。 12345678910111213141516171819@NotThreadSafe public class NumberRange &#123; private int lower, upper; public int getLower() &#123; return lower; &#125; public int getUpper() &#123; return upper; &#125; public void setLower(int value) &#123; if (value &gt; upper) throw new IllegalArgumentException(...); lower = value; &#125; public void setUpper(int value) &#123; if (value &lt; lower) throw new IllegalArgumentException(...); upper = value; &#125;&#125; 这种方式限制了范围的状态变量，因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；从而仍然需要使用同步。否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是 (0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是 (4, 3) —— 一个无效值。至于针对范围的其他操作，我们需要使 setLower() 和 setUpper() 操作原子化 —— 而将字段定义为 volatile 类型是无法实现这一目的的。 性能考虑使用 volatile 变量的主要原因是其简易性：在某些情形下，使用 volatile 变量要比使用相应的锁简单得多。使用 volatile 变量次要原因是其性能：某些情况下，volatile 变量同步机制的性能要优于锁。很难做出准确、全面的评价，例如 “X 总是比 Y 快”，尤其是对 JVM 内在的操作而言。（例如，某些情况下 VM 也许能够完全删除锁机制，这使得我们难以抽象地比较 volatile 和 synchronized 的开销。）就是说，在目前大多数的处理器架构上，volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样。而 volatile 写操作的开销要比非 volatile 写操作多很多，因为要保证可见性需要实现内存界定（Memory Fence），即便如此，volatile 的总开销仍然要比锁获取低。 正确使用volatile模式很多并发性专家事实上往往引导用户远离 volatile 变量，因为使用它们要比使用锁更加容易出错。然而，如果谨慎地遵循一些良好定义的模式，就能够在很多场合内安全地使用 volatile 变量。要始终牢记使用 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile —— 这条规则能够避免将这些模式扩展到不安全的用例。 状态标志 一次性安全发布 独立观察 volatile bean 开销较低的读－写锁策略 状态标志1234567891011volatile boolean shutdownRequested;...public void shutdown() &#123; shutdownRequested = true; &#125;public void doWork() &#123; while (!shutdownRequested) &#123; // do stuff &#125;&#125; 很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。（可能会从 JMX 侦听程序、GUI 事件线程中的操作侦听程序、通过 RMI 、通过一个 Web 服务等调用）。然而，使用 synchronized 块编写循环要比使用清单 2 所示的 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从 false 到 true，再转换到 false）。此外，还需要某些原子状态转换机制，例如原子变量。 次性安全发布12345678910111213141516171819public class BackgroundFloobleLoader &#123; public volatile Flooble theFlooble; public void initInBackground() &#123; // do lots of stuff theFlooble = new Flooble(); // this is the only write to theFlooble &#125;&#125;public class SomeOtherClass &#123; public void doWork() &#123; while (true) &#123; // do some stuff... // use the Flooble, but only if it is ready if (floobleLoader.theFlooble != null) doSomething(floobleLoader.theFlooble); &#125; &#125;&#125; 如果 theFlooble 引用不是 volatile 类型，doWork() 中的代码在解除对 theFlooble 的引用时，将会得到一个不完全构造的 Flooble。该模式的一个必要条件是：被发布的对象必须是线程安全的，或者是有效的不可变对象（有效不可变意味着对象的状态在发布之后永远不会被修改）。volatile 类型的引用可以确保对象的发布形式的可见性，但是如果对象的状态在发布后将发生更改，那么就需要额外的同步。 独立观察12345678910111213public class UserManager &#123; public volatile String lastUser; public boolean authenticate(String user, String password) &#123; boolean valid = passwordIsValid(user, password); if (valid) &#123; User u = new User(); activeUsers.add(u); lastUser = user; &#125; return valid; &#125;&#125; 该模式是前面模式的扩展；将某个值发布以在程序内的其他地方使用，但是与一次性事件的发布不同，这是一系列独立事件。这个模式要求被发布的值是有效不可变的 —— 即值的状态在发布后不会更改。使用该值的代码需要清楚该值可能随时发生变化。 volatile bean12345678910111213141516171819202122@ThreadSafepublic class Person &#123; private volatile String firstName; private volatile String lastName; private volatile int age; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getAge() &#123; return age; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; volatile bean 模式适用于将 JavaBeans 作为“荣誉结构”使用的框架。在 volatile bean 模式中，JavaBean 被用作一组具有 getter 和/或 setter 方法 的独立属性的容器。volatile bean 模式的基本原理是：很多框架为易变数据的持有者（例如 HttpSession）提供了容器，但是放入这些容器中的对象必须是线程安全的。在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。（这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义）。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。 开销较低的读－写锁策略123456789101112@ThreadSafepublic class CheesyCounter &#123; // Employs the cheap read-write lock trick // All mutative operations MUST be done with the 'this' lock held @GuardedBy(\"this\") private volatile int value; public int getValue() &#123; return value; &#125; public synchronized int increment() &#123; return value++; &#125;&#125; 总结与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。本文介绍的模式涵盖了可以使用 volatile 代替 synchronized 的最常见的一些用例。遵循这些模式（注意使用时不要超过各自的限制）可以帮助您安全地实现大多数用例，使用 volatile 变量获得更佳性能。 最近访客","tags":[{"name":"volatile","slug":"volatile","permalink":"http://www.jackway.cn/tags/volatile/"},{"name":"synchronized","slug":"synchronized","permalink":"http://www.jackway.cn/tags/synchronized/"}]},{"title":"JMM-重排序","date":"2016-12-17T02:50:07.000Z","path":"2016/12/17/JMM-1/","text":"首先我们都知道，android开发的主要语言是java，其实android上的java还是有点区别的，在此不展开讲解，这篇专注内存模型，内存重排的问题进行讲解。很多人可能在想，重排是什么鬼，什么情况下会出现重排，重排对程序有是否影响，怎么避免重排等等一系列的疑问。下面我对每个疑问进行剖析。 话题大纲 数据依赖性 as-if-serial 程序顺序规则，也就是happens－before规则 重排对多线程的影响 数据依赖如果两个操作访问同一个变量，且两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性，你如：a=1;b=a; b依赖a的写操作。这种情况下，会阻止重排，因为重排之后，必然导致最后结果不一致，但是在很多场景下，我们写的代码都有这种依赖存在。 as-if-serial这个规则简单的来说就是对编译器。runtime，cpu的一种约束，单线程条件下，重排之后，最后结果要一致, 这些约束并不能保证多线程环境下成立。所以在并发的环境下，需要我们自己保证这种约束。 程序顺序规则，也就是happens－before规则 A happens- before B； B happens- before C； A happens- before C； 这里的第3个happens- before关系，是根据happens- before的传递性推导出来的。这里A happens- before B，但实际执行时B却可以排在A之前执行（看上面的重排序后的执行顺序）。在第一章提到过，如果A happens- before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens- before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not illegal），JMM允许这种重排序。在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从happens- before的定义我们可以看出，JMM同样遵从这一目标。 重排对多线程的影响12345678910111213141516class ReorderExample &#123;int a = 0;boolean flag = false;public void writer() &#123; a = 1; //1 flag = true;//2&#125;Public void reader() &#123; if (flag) &#123;//3 int i = a * a;//4 …… &#125;&#125;&#125; 多线程情况下rw操作就可能出现很多不确定性，大概有以下场景，w操作重排，r操作cpu内部重排，最后的结果不言而喻。这里我们看到是重排对多线程的影响，如果是单线程就不存在重排的概念了。 扩展 内存重排的解决方法（volatile） 内存可见性与重排的关系 最近访客","tags":[{"name":"dependencies","slug":"dependencies","permalink":"http://www.jackway.cn/tags/dependencies/"},{"name":"controlFlow","slug":"controlFlow","permalink":"http://www.jackway.cn/tags/controlFlow/"},{"name":"resort","slug":"resort","permalink":"http://www.jackway.cn/tags/resort/"}]},{"title":"CAS为什么如此的乐观了?","date":"2016-12-13T03:33:21.000Z","path":"2016/12/13/cas-1/","text":"CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。这听起来可能有一点复杂但是实际上你理解之后发现很简单，接下来，让我们更深入的了解一下这项技术。 议题大纲 cas是什么 cas是怎么做到无锁原子操作的 cas跟synchronized,lock等锁机制的区别是什么 cas的性能如何 cas使用过程中我们需要注意的问题是什么 cas 是什么cas通俗的讲就是一种比较交换的操作，但是这个操作跟普通操作不太一样，主要不一样的是，这个操作可能失败，需要重试。同时cas不是虚拟机层面的原子保证，是利用cpu指令实现的一种原子保证，利用cpu总线，缓存实现的一种无锁并发技术。 cas是怎么做到无锁原子操作的利用cpu指令集同时cpu的总线，缓存特性。其实cpu层还是加锁的，只是将虚拟机层面的加锁，委派给了cpu层面。 cas跟synchronized等锁机制的区别是什么cas是一种乐观锁，而synchronized是一种悲观锁，乐观的也是就是，如果原子操作失败，会重试，悲观的就不会。 cas的性能如何cas由于需要重试，所以性能上可能有点损失，在临界资源竞争激烈的情况下，但是总体性能还是乐观的。 cas使用过程中我们需要注意的问题是什么cas 由于是一种基于比较交换机制，所以我们在一些场景一定要重试，重新获取，才能真正的保证数据的准确性，一致性，安全性。 cas我们有哪些场景了，其实android里面场景就很多，我们看几个简单的场景. View id的产生1234567891011public static int generateViewId() &#123; for (;;) &#123; final int result = sNextGeneratedId.get(); // 获取当前id // aapt-generated IDs have the high byte nonzero; clamp to the range under that. int newValue = result + 1; // 新的id if (newValue &gt; 0x00FFFFFF) newValue = 1; // Roll over to 1, not 0. // 可能跟aapt工具产生的冲突，需要回滚 if (sNextGeneratedId.compareAndSet(result, newValue)) &#123; // 自旋设置最新值，如果失败，需要重试 return result; &#125; &#125; &#125; 这个是android View里面的一个类方法，当我们动态setId的时候，如果id无效，那么会调用这个方法自动产生一个有效的id，这里用cas机制实现了，id的有效性, 同时也佩服google的工程师，考虑问题很全，这里aapt产生的id不会在新值之内，做了过滤，比如系统资源0x01开头，应用资源0x7F开头，0x00FFFFFF这个值就是临界值，所以我们在插件开发的时候，也需要兼容框架层一下，我们定制aapt也是用开始的一个字节。 AtomicBoolean 源码剖析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class AtomicBoolean implements java.io.Serializable &#123; private static final long serialVersionUID = 4654671469794556979L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicBoolean.class.getDeclaredField(\"value\")); // jni层的偏移值，为了后面的自旋比较 &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; // 最新值 /** * Creates a new &#123;@code AtomicBoolean&#125; with the given initial value. * * @param initialValue the initial value */ public AtomicBoolean(boolean initialValue) &#123; value = initialValue ? 1 : 0; &#125; /** * Creates a new &#123;@code AtomicBoolean&#125; with initial value &#123;@code false&#125;. */ public AtomicBoolean() &#123; &#125; /** * Returns the current value. * * @return the current value */ public final boolean get() &#123; return value != 0; &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */ public final boolean compareAndSet(boolean expect, boolean update) &#123; // 这个方法是final int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u); &#125; /** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;&lt;a href=\"package-summary.html#weakCompareAndSet\"&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to &#123;@code compareAndSet&#125;. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful */ public boolean weakCompareAndSet(boolean expect, boolean update) &#123; // 这个跟compareAndSet逻辑一样，但是不是final，意味着子类可以覆盖逻辑，进行自定义 int e = expect ? 1 : 0; int u = update ? 1 : 0; return unsafe.compareAndSwapInt(this, valueOffset, e, u); // cas操作 &#125; /** * Unconditionally sets to the given value. * * @param newValue the new value */ public final void set(boolean newValue) &#123; value = newValue ? 1 : 0; &#125; /** * Eventually sets to the given value. * * @param newValue the new value * @since 1.6 */ public final void lazySet(boolean newValue) &#123; // 延迟设置到最新值 int v = newValue ? 1 : 0; unsafe.putOrderedInt(this, valueOffset, v); &#125; /** * Atomically sets to the given value and returns the previous value. * * @param newValue the new value * @return the previous value */ public final boolean getAndSet(boolean newValue) &#123; // 获取旧值，设置最新值 boolean prev; do &#123; prev = get(); // 获取旧值 &#125; while (!compareAndSet(prev, newValue)); // false 意味着有线程更新了value，需要轮询，保证数据的准确性，一致性。 return prev; &#125; /** * Returns the String representation of the current value. * @return the String representation of the current value */ public String toString() &#123; return Boolean.toString(get()); &#125;&#125; 场景还有很多,比如单例场景 等等。 总结那我们到底什么时候选择cas，什么时候选择加锁了，这个没有一定，需要根据具体场景，选择合适的方式。cas总体上来说，性能优越加锁。但是当资源竞争很大的时候，轮询次数增加，导致性能有点下降。移动端并发数目不会很大，如果是服务端需要对cas进一步优化。 cas只能保证单一变量操作的原子性，如果需要保证多个变量，那么使用对象，然后数据封装到对象进行atomic，AtomicReference 有兴趣的可以了解，还有很多数据结构实现的无锁操作，也可以去学习，了解。 最近访客","tags":[{"name":"CAS","slug":"CAS","permalink":"http://www.jackway.cn/tags/CAS/"}]},{"title":"线程启动之后可以停止吗?","date":"2016-12-12T06:17:50.000Z","path":"2016/12/12/thread-stop/","text":"异步任务最后都会回归到Thread这个类，所以我们很有必要深入理解一下这个类，才能写基础框架，才能理解目前大名鼎鼎的线程池框架，不得不佩服并发大神Doug Lea对java并发做出的共享，也就是很多人所说，java具有先天高并发的特性。下面分析一下我们常见的场景，任务的停止处理. stop 有作用吗? 肯定是不好使的, 抛出UnsupportedOperationException,并且如果我们程序没处理异常，直接导致程序crash，那我们怎么才能stop了,下面通过两种方式实现stop,但是也是不可靠的,毕竟是一种协助stop。 解决方式 stop flag interrupted stop flag1234567891011121314151617181920212223private static final String TAG = ThreadInterrupt.class.getSimpleName(); private volatile boolean isStop; public ThreadInterrupt2() &#123; start(); &#125; @Override public void run() &#123; super.run(); while (!isStop) &#123; System.out.println(\"run......\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void stopThread() &#123; isStop = true; &#125; interrupted1234567891011121314151617181920212223242526private static final String TAG = ThreadInterrupt.class.getSimpleName(); private Thread mThread; public ThreadInterrupt() &#123; mThread = new Thread(this); mThread.start(); &#125; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted()) &#123;// 判断是否被打断，但是不会清除打断标志 Log.e(TAG, \"alive......\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); Log.e(TAG, Thread.currentThread().interrupted() + \"\");// 是否打断，同时清除打断标志 Thread.currentThread().interrupt(); // 打断复原,根据需求是否需要复原 &#125; &#125; Log.e(TAG, \"stop......\"+Thread.currentThread().interrupted()+\"/\"+Thread.currentThread().interrupted()); // true/false &#125; public void stop() &#123; mThread.interrupt(); &#125; 注意上面两种都可以实现线程的停止,那么哪种更好了，我建议用第二种，首先无需定义额外的标志，然后就是代码比较清晰，充分利用了内部特性，并且更高效，可靠。 为什么第一种实现不好了?首先需要定义额外标志，意味着需要额外的存储空间，同时volatile jdk1.5之前不可靠，意味着不能真正停止任务，sleep必须等待有线程打断才可能停止任务。 最近访客","tags":[{"name":"thread","slug":"thread","permalink":"http://www.jackway.cn/tags/thread/"},{"name":"runnable","slug":"runnable","permalink":"http://www.jackway.cn/tags/runnable/"},{"name":"stop","slug":"stop","permalink":"http://www.jackway.cn/tags/stop/"}]},{"title":"git submodule","date":"2016-12-08T03:36:11.000Z","path":"2016/12/08/gitsubmodule-1/","text":"有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。 我们举一个例子。 假设你正在开发一个网站然后创建了 Atom 订阅。 你决定使用一个库，而不是写自己的 Atom 生成代码。 你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到自己的项目中。 如果将这个库包含进来，那么无论用何种方式都很难定制它，部署则更加困难，因为你必须确保每一个客户端都包含该库。 如果将代码复制到自己的项目中，那么你做的任何自定义修改都会使合并上游的改动变得困难。 Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。 开始使用子模块我们将要演示如何在一个被分成一个主项目与几个子项目的项目上开发。git submodule add &lt;repository&gt; [path] path是可选字断，默认子模块的工程名主工程添子模块之后,只会克隆工程空目录，然后进入子工程目录执行git submodule init, git submodule update或者git submodule update --init 拉取子工程文件,运行git status 你会注意到工程主目录添加了.gitmodules文件与子工程的目录,.gitmodules纪录所有子模块与物理路径的映射。git diff --cached submodulename 列出子模块改变，在主工程使用git commit -am&#39;xxx&#39;提交子模块工程的纪录为160000模式， 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件 克隆有子模块的项目首先克隆主工程 git clone &lt;repository&gt; [-b &lt;name&gt;],主工程根目录包含.gitmodules文件纪录了所有的子模块,进入子模块,执行git submodule init 初始化子工工程,git submodule update 更新子工程,简便方式git clone --recursive &lt;repository&gt; 递归初始化更新子工程,有时需要进入子模块git merge origin/master 合并上游的更新 在包含子模块的项目上工作 拉取上有修改 在项目中使用子模块的简单模型就是拉取子模块最新纪录，git fetch, git merge origin/master 拉取合并上游最新更新在主工程目录运行git diff --submodule 显示最新提交与提交的列表,设置log默认行为git config --global diff.submodule log ,在主工程中更新子模块git submodule update --remote &lt;submodulename&gt; 此命令默认会假定你想要更新并检出子模块仓库的 master 分支。 不过你也可以设置为想要的其他分支。 例如，你想要子模块跟踪仓库的 “stable” 分支，那么既可以在 .gitmodules 文件中设置（这样其他人也可以跟踪它），也可以只在本地的 .git/config 文件中设置。 让我们在 .gitmodules 文件中设置它：git config -f .gitmodules submodule.&lt;submodulename&gt;.branch &lt;branchname&gt; 如果不用 -f .gitmodules 选项，那么它只会为你做修改。但是在仓库中保留跟踪信息更有意义一些，因为其他人也可以得到同样的效果。如果你设置了配置选项 status.submodulesummary，Git 也会显示你的子模块的更改摘要：git config status.submodulesummary 1 ,这时如果运行 git diff，可以看到我们修改了 .gitmodules 文件，同时还有几个已拉取的提交需要提交到我们自己的子模块项目中。这非常有趣，因为我们可以直接看到将要提交到子模块中的提交日志。 提交之后，你也可以运行 git log -p 查看这个信息。git log -p --submodule 当运行 git submodule update --remote 时，Git 默认会尝试更新所有子模块，所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。在子模块上工作 你很有可能正在使用子模块，因为你确实想在子模块中编写代码的同时，还想在主项目上编写代码（或者跨子模块工作）。 否则你大概只能用简单的依赖管理系统（如 Maven 或 Rubygems）来替代了。 现在我们将通过一个例子来演示如何在子模块与主项目中同时做修改，以及如何同时提交与发布那些修改。到目前为止，当我们运行 git submodule update 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 “游离的 HEAD” 的状态。 这意味着没有本地工作分支（例如 “master”）跟踪改动。 所以你做的任何改动都不会被跟踪。 为了将子模块设置得更容易进入并修改，你需要做两件事。 首先，进入每个子模块并检出其相应的工作分支。 接着，若你做了更改就需要告诉 Git 它该做什么，然后运行 git submodule update --remote 来从上游拉取新工作。 你可以选择将它们合并到你的本地工作中，也可以尝试将你的工作变基到新的更改上。 首先，让我们进入子模块目录然后检出一个分支。git checkout &lt;branchname&gt;然后尝试用 “merge” 选项。 为了手动指定它，我们只需给 update 添加 –merge 选项即可。 这时我们将会看到服务器上的这个子模块有一个改动并且它被合并了进来。git submodule update --remote --merge如果我们现在更新子模块，就会看到当我们在本地做了更改时上游也有一个改动，我们需要将它并入本地。git submodule update --remote --rebase如果你忘记 –rebase 或 –merge，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。git submodule update --remote即便这真的发生了也不要紧，你只需回到目录中再次检出你的分支（即还包含着你的工作的分支）然后手动地合并或变基 origin/stable（或任何一个你想要的远程分支）就行了。 如果你没有提交子模块的改动，那么运行一个子模块更新也不会出现问题，此时 Git 会只抓取更改而并不会覆盖子模块目录中未保存的工作。git submodule update --remote如果你做了一些与上游改动冲突的改动，当运行更新时 Git 会让你知道。你可以进入子模块目录中然后就像平时那样修复冲突发布子模块改动现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。git diff如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。 那些改动只存在于我们本地的拷贝中。 为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。 git push 命令接受可以设置为 “check” 或 “on-demand” 的 –recurse-submodules 参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使 push 操作失败。git push --recurse-submodules=check如你所见，它也给我们了一些有用的建议，指导接下来该如何做。 最简单的选项是进入每一个子模块中然后手动推送到远程仓库，确保它们能被外部访问到，之后再次尝试这次推送。git push --recurse-submodules=on-demand合并子模块改动 如果你其他人同时改动了一个子模块引用，那么可能会遇到一些问题。 也就是说，如果子模块的历史已经分叉并且在父项目中分别提交到了分叉的分支上，那么你需要做一些工作来修复它。 如果一个提交是另一个的直接祖先（一个快进式合并），那么 Git 会简单地选择之后的提交来合并，这样没什么问题。不过，Git 甚至不会尝试去进行一次简单的合并。 如果子模块提交已经分叉且需要合并，那你会得到类似下面的信息：git pull所以本质上 Git 在这里指出了子模块历史中的两个分支记录点已经分叉并且需要合并。 它将其解释为 “merge following commits not found”（未找到接下来需要合并的提交），虽然这有点令人困惑，不过之后我们会解释为什么是这样。 为了解决这个问题，你需要弄清楚子模块应该处于哪种状态。 奇怪的是，Git 并不会给你多少能帮你摆脱困境的信息，甚至连两边提交历史中的 SHA-1 值都没有。 幸运的是，这很容易解决。 如果你运行 git diff，就会得到试图合并的两个分支中记录的提交的 SHA-1 值。git diff diff --cc DbConnector index eb41d76,c771610..0000000 --- a/DbConnector +++ b/DbConnector 所以，在本例中，eb41d76 是我们的子模块中大家共有的提交，而 c771610 是上游拥有的提交。 如果我们进入子模块目录中，它应该已经在 eb41d76 上了，因为合并没有动过它。 如果不是的话，无论什么原因，你都可以简单地创建并检出一个指向它的分支。 来自另一边的提交的 SHA-1 值比较重要。 它是需要你来合并解决的。 你可以尝试直接通过 SHA-1 合并，也可以为它创建一个分支然后尝试合并。 我们建议后者，哪怕只是为了一个更漂亮的合并提交信息。 所以，我们将会进入子模块目录，基于 git diff 的第二个 SHA 创建一个分支然后手动合并。 子模块技巧git submodule foreach &#39;git stash&#39;git submodule foreach &#39;git checkout -b featureA&#39;git submodule foreach &#39;git diff&#39;有用的别名 你可能想为其中一些命令设置别名，因为它们可能会非常长而你又不能设置选项作为它们的默认选项。 我们在 Git 别名 介绍了设置 Git 别名，但是如果你计划在 Git 中大量使用子模块的话，这里有一些例子。 $ git config alias.sdiff &#39;!&#39;&quot;git diff &amp;&amp; git submodule foreach &#39;git diff&#39;&quot;$ git config alias.spush &#39;push --recurse-submodules=on-demand&#39;$ git config alias.supdate &#39;submodule update --remote --merge&#39; 最近访客","tags":[{"name":"git","slug":"git","permalink":"http://www.jackway.cn/tags/git/"},{"name":"submodule","slug":"submodule","permalink":"http://www.jackway.cn/tags/submodule/"}]},{"title":"一线互联网公司面试简单分析","date":"2016-12-07T10:46:41.000Z","path":"2016/12/07/interview-1/","text":"介绍自己负责的部分，如何实现的。 自定义view viewGroup activity的启动流程 事件传递及滑动冲突的处理 插件化（activity如何加载及资源处理 内存优化 ，如何避免oom 内存泄漏如何处理及如何排查 handler问题 图片加载用的什么以及原理 从一堆数据里怎么查找最大的n个数 快速排序 字符串匹配 介绍自己负责的部分，如何实现的 这个把自己负责的模块说清楚就好,一般有一下几个方面可以说一下，前提是不要给自己挖坑 自己负责模块在整个项目中的角色,也就是功能描述 开发前的自己的一些思考,比如对业务的抽象,接口的定义，协议的定义等等 开发编码过程中遇到的难点以及坑 排查问题以及结解决方式 兼容性保证 性能优化 上线之后模块导致crash的比例 自定义view viewGroup 这个就是约定的几个方法,onMeasure,onLayout,onDraw,measure,layout,draw同时注意写方法的调用时机以及区别,比如onMeasure是个模版方法是在measure下调用的,这个方法在viewGroup里面,自定义的这些就已经足够了，如果还扩展一些更新问题，子线程能不能更新，是可以的,在ViewRootImpl没创建之前可以更新，不同sdk这个类可能名字不一样。 activity的启动流程 这个肯定不是说activity的生命周期，是启动加载过程,大致说下流程,具体的要自己看代码了，大致过程有:这里可能分好几种情况,其实都差不很多，这里就说一种情况,startActivity这个怎么启动Activity的,startActivity-&gt;ActivityManagerService-&gt;ActivityThread-&gt;Activity,大概参与就这几个核心类,里面经过了两层binder通信,最后路由到IApplicationThread,然后到ActivityThread中的H消息队列中启动Activity，细节很多，可以在评论询问。 事件传递及滑动冲突的处理 事件传递理解成责任链式调用就好，也就是从最内层到外层时间委派，如果事件consume了，那么就给这个view处理，不然从外向内冒泡，冲突处理举个实例就好，比如SlideMenu与banner或者ListView与Scrollview的冲突等等，说出基本思路就行，这些解决一般都是重写那几个事件方法，然后各种判断就好 插件化（activity如何加载及资源处理) Activity使用占坑hook加载,也可以使用静态代理，静态代理就需要自定义classloader,记住这个加载模式就行，再多细节在评论回复吧，资源处理就是assetmanager的创建，然后资源冲突处理，简单的可以构建多个assetmanager就没有冲突问题，应为隔离了，如果使用一个那么打包aapt定制一下就行,还有很多细节，在评论回复吧，说不完了。 内存优化 ，如何避免oom 内存优化太多要说的了，有套路的回答，基本就是避免跟gc配合好工作，比如：尽量复用对象，处理无用对象，避免内存泄漏，压缩对象等等，尽量将大对象特殊处理，比如bitmap占用内存较多，可以jni层与java层配合一起，大小压缩，质量压缩，imsimplesize的大小定义，规范等等，程序中有内存管理模块，避免内存压力大的时候，能够释放内存，避免oom发生的几率，还有很多方面，在评论回复吧。 内存泄漏如何处理及如何排查 内存泄漏最大的问题就是无用对象常驻内存，导致内存压力很大，最后可能导致oom发生。尽量将对象生命周期可以在控制的能力之内，具体的在回复说吧，也很多场景,比如：context 除了特殊情况用activity，其他我们没理由不用application。排查导出堆空间，然后mat分析，程序里面用leackcanary定位。 handler问题 这个需要回复两个基本的，首先handler的创建需要loop，loop怎么创建的，同时这个里面怎么保证loop线程安全的，还有就是消息如何分发的，也就是消息发送到接受的流程，还有callback对消息处理的影响，这些足够了，还可以说可以跨进程，这样就更棒了，具体的在回复说，太多了。 图片加载用的什么以及原理 图片加载的太多了，说个自己非常熟悉的就行，不要给自己挖坑，都懂的，比如你熟悉uil，那就说具体的加载过程，套路都差不多，都是创建图片task，先从缓存取出来，取不到就去网络下载，下载完之后，同时缓存起来，这里需要说下，线程池，队列，pause，resume的具体细节，比如跟view，activity的绑定关系。回复具体说，也很多 从一堆数据里怎么查找最大的n个数 这个用归并排序，或者直接快排，没啥还说的。不会的自己google看算法，算法后面我会写出来到文章里面。 快速排序 基本思想挖坑，分而治之，按照这个思路看代码就行 字符串匹配 这个kmp算法，或者最基本的吧，不考虑时间，空间复杂度的条件下，但是不要说这个，太low了点。其实这些算法背下来就好，不是业务场景的，意义不大，但是必须要会,不然吃亏了 架构 其实架构没有固定模式，能够说出自己对架构的理解就很好，比如mvp，不同人对这个理解不一样，最好的，够用的，最适合业务的才是好架构，这个也很多要说，评论说吧。 最近访客","tags":[{"name":"alog","slug":"alog","permalink":"http://www.jackway.cn/tags/alog/"},{"name":"ams","slug":"ams","permalink":"http://www.jackway.cn/tags/ams/"}]},{"title":"打破标准的第一个OC程序","date":"2016-12-06T13:36:07.000Z","path":"2016/12/06/ios-oc-1/","text":"平时我们写程序第一个程序都是hello world,这次开始就不用老套路了，用字符串的基本用法开始，我认为标准的hello world 其实就是一个字符串,但是我们从程序的角度看，就是一个空虚的字符串，不能让我们想到更多，我想如果能否说一些字符串的基本操作可能更有意思，一方面是基础语法，另一方面也理解了oc字符串对象与java的不同点。 NSString oc里面对象都是以NS开头的，记住就行，要想知道为什么的去google吧! oc里面的字符串与java最大的不同就是，java里面是个引用，而oc里面是个指针，跟c/c++ 很类似。 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... // 字符串 NSString* str = @\"first oc\"; NSUInteger len = str.length; // 获取字符串的长度，跟java差不多，只是java是一个方法，而oc是一个属性 BOOL contain = [str containsString:@\"bc\"]; // 判断子串 NSLog(@\"str:%@ contain %@ %hhd\",str,@\"bc\",contain); // 格式化打印,跟c/c++ printf长的很像，跟java的System.out.println 差不多 NSString* result = [str stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:@\"b\"]; // 字符串子串替换 NSString* sub = [str substringFromIndex:3]; // 获取子串 NSLog(@\"%@ %lu %@ sub\", str,len,sub); NSLog(@\"result:%@\",result); for (int i=0; i&lt; len; ++i) &#123;// 遍历字符串 NSLog(@\"c:%c\",[str characterAtIndex:i]); &#125; // 静态方法 将字符数组转换成os string NSString* chars = [NSString stringWithCString:\"oc\" encoding:NSUTF8StringEncoding]; NSLog(@\"chars %@\",chars); &#125; return 0;&#125; oc 里面导入基础库跟java一样，只是java导入的是类或者静态方法，而oc导入的是头文件，也是是实现的声明，因为oc不开源，我们只能通过看到头文件的具体声明。其中oc里面Foundation.h 这个是基础更能核心库，后面还有uikit等核心库。第一个程序看起来很简单，其实里面很多语法细节，后面慢慢来讲吧，往往简单的东西背后都是复杂。 最近访客","tags":[{"name":"oc","slug":"oc","permalink":"http://www.jackway.cn/tags/oc/"},{"name":"NSString","slug":"NSString","permalink":"http://www.jackway.cn/tags/NSString/"}]},{"title":"wait和sleep 深度分析","date":"2016-12-05T06:08:43.000Z","path":"2016/12/05/wait-sleep/","text":"首先我们需要明白wait与sleep的区别，区别大致有下面几个方面: wait是Object中的方法,sleep是Thread中的方法 wait必须在同步代码块中调用，也就是说必须首先获得监视器锁，然后才能调用,sleep可以在任何可能的地方调用 wait释放锁,sleep不释放锁 wait尽可能的少消耗cpu资源,sleep消耗更多的cpu资源 下面分析一种wait协助的场景，如果换成sleep可能导致死锁 wait协助代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class TestThread &#123; private static final String TAG = TestThread.class.getSimpleName(); private static final Map&lt;String, Object&gt; MAP = new WeakHashMap&lt;&gt;(); private static final Object WAIT = new Object(); public Object get(String key) &#123; Object object; synchronized (MAP) &#123; Log.e(TAG, \"tid:\" + Thread.currentThread().getId()); do &#123; object = MAP.get(key); if (object == WAIT) &#123;// 线程等待 Log.e(TAG, \"wait......\"); try &#123; MAP.wait(); //Thread.sleep(1000); Log.e(TAG,\"wake....\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; else if (object != null) &#123; // hit Log.e(TAG, \"hit:\" + object); return object; &#125; else &#123; MAP.put(key, WAIT); // 存放wait对象 break; &#125; &#125; while (true); &#125; Log.e(TAG, \"generate....\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (MAP) &#123; object = UUID.randomUUID().toString(); Log.e(TAG, object.toString()); if (object != null) &#123; MAP.put(key, object); // 存放真正数据 &#125; else &#123; MAP.remove(key); // 如果获取数据失败,需要删除对应的key,让等待对象自己获取 &#125; MAP.notifyAll(); // 通知在MAP上的所有等待对象 &#125; return object; &#125;&#125; 上面代码可以正常协助,如果将MAP.wait() 替换成 Thread.sleep(1000) 就很可能导致死锁 注意 通过上面代码我们在写并发代码的时候，一定要理解场景，不然真的很危险. 最近访客","tags":[{"name":"wait","slug":"wait","permalink":"http://www.jackway.cn/tags/wait/"},{"name":"sleep","slug":"sleep","permalink":"http://www.jackway.cn/tags/sleep/"}]},{"title":"shareUID","date":"2016-12-03T05:45:14.000Z","path":"2016/12/03/shareUID/","text":"shareUID是提供已经安装app之间的数据访问的通道，我们最常见的场景就是同一个公司不同的app安装在同一手机上，在某些时候可能需要数据，资源，代码共享，但是实现该目的也是有一定限制的，首先保证app之间的签名一致，同时shareUID值相等，才能完全无障碍访问所有资源，不然只能访问部分资源，代码，sharedPreferences等资源是没法访问到的，即使访问到的也是非安全的。 shareuid常见数据共享的方式有 用户数据共享 资源共享 代码共享 用户数据共享1234String filename = \"share\"; String key = \"share\"; String value = ShareUtils.getStringValue(this, targetPackagename, filename, key, \"\"); Log.e(TAG, \"value:\" + value); 资源共享12String app_name = ShareUtils.getResString(this, targetPackagename, \"app_name\"); Log.e(TAG, \"app_name:\" + app_name); 代码共享1234567891011121314151617181920String cName = \"com.longway.share.Print\"; Class&lt;?&gt; clz = ShareUtils.loadClass(this, targetPackagename, cName); if (clz != null) &#123; try &#123; Object o = clz.newInstance(); Method method = clz.getDeclaredMethod(\"print\", String.class); if (!method.isAccessible()) &#123; method.setAccessible(true); &#125; method.invoke(o, TAG); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; 以上只是简单的提供数据访问的几种方式面，比如数据库，assets等等都是可以访问的，但是访问的时候需要考虑数据安全。 访问数据简单代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ShareUtils &#123; private ShareUtils() &#123; &#125; public static String getStringValue(Context context, String targetPackname, String filename, String key, String dv) &#123; try &#123; Context ctx = context.createPackageContext(targetPackname, Context.CONTEXT_IGNORE_SECURITY); SharedPreferences sharedPreferences = ctx.getSharedPreferences(filename, Context.MODE_PRIVATE); return sharedPreferences.getString(key, dv); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return dv; &#125; public static String getResString(Context context, String targetPackname, String resName, Object... args) &#123; try &#123; Context ctx = context.createPackageContext(targetPackname, Context.CONTEXT_IGNORE_SECURITY); Resources resources = ctx.getResources(); int id = resources.getIdentifier(resName, \"string\", targetPackname); if (id == 0) &#123; return null; &#125; return resources.getString(id, args); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static String getAppname(Context context, String targetPackname,int id) &#123; try &#123; Context ctx = context.createPackageContext(targetPackname, Context.CONTEXT_IGNORE_SECURITY); Resources resources = ctx.getResources(); return resources.getString(id); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static Class&lt;?&gt; loadClass(Context context, String targetPackagename, String name) &#123; try &#123; Context ctx = context.createPackageContext(targetPackagename,Context.CONTEXT_IGNORE_SECURITY|Context.CONTEXT_INCLUDE_CODE); ClassLoader classLoader = ctx.getClassLoader(); Log.e(\"loader\", (context.getClassLoader() == classLoader) + \"\"); Log.e(\"pathClassLoader\", (classLoader instanceof PathClassLoader) + \"\"); return classLoader.loadClass(name); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 注意 shareuid的前提是app已经安装到了设备中，不然是访问不了的，如果是没安装的访问，就只能用插件化的方式去加载，然后去访问了。根据自己的需求，选择对应的技术实现就好了。 查看源码实例 最近访客","tags":[{"name":"shareUID","slug":"shareUID","permalink":"http://www.jackway.cn/tags/shareUID/"},{"name":"Context","slug":"Context","permalink":"http://www.jackway.cn/tags/Context/"}]},{"title":"SharedPreferences真的安全吗?","date":"2016-12-02T19:04:51.000Z","path":"2016/12/03/safesharepreferences/","text":"SharedPreferences是单进程线程安全,Android系统进程之间的内存是隔离的,这样就导致了进程之间如果访问同一个数据文件,进行数据共享通信的时候,可能会出现下面几种异常: 数据不一致 数据异常 文件异常 进程之间数据共享要想实现进程中之间安全通信,我们需要将不同进程之间对数据的访问映射到同一个数据进程,然后通过这个进程实现线程安全实现数据通信,我们可以将这个进程理解为代理进程,Android系统已经提供给我们ContentProvider进程,我们通过这个就可以实现安全通信 进程之间数据共享图例 Usage 注册进程之间数据观察者(非必须) 123456789private SharePreferencesObserver mSharePreferencesObserver = new SharePreferencesObserver() &#123; @Override public void onSharePreferencesChange(SharePreferencesObservable sharePreferencesObservable, String key) &#123; //Log.e(TAG, \"key:\" + key + \",value:\" + mSharePreferencesManager.getBoolean(key, false)); Log.e(TAG, \"map result &lt;&lt;\" + mSharePreferencesManager.getAll().toString()); &#125; &#125;;mSharePreferencesManager.registerOnSharePreferencesObserver(mSharePreferencesObserver); 数据访问 123456789101112131415161718Log.e(TAG, mSharePreferencesManager.putBoolean(\"isExpire\", true) + \"\");Log.e(TAG, mSharePreferencesManager.contains(\"isExpire\") + \"\");Log.e(TAG, mSharePreferencesManager.getBoolean(\"isExpire\", false) + \"\");Log.e(TAG, mSharePreferencesManager.putInt(\"int\", 3) + \"\");Log.e(TAG, mSharePreferencesManager.getInt(\"int\", -1) + \"\");Log.e(TAG, mSharePreferencesManager.putFloat(\"float\", 3.9f) + \"\");Log.e(TAG, mSharePreferencesManager.getFloat(\"float\", 0.0f) + \"\");Log.e(TAG, mSharePreferencesManager.putLong(\"long\", 40L) + \"\");Log.e(TAG, mSharePreferencesManager.getLong(\"long\", 0L) + \"\");Log.e(TAG, mSharePreferencesManager.putString(\"string\", \"小马哥\") + \"\");Log.e(TAG, mSharePreferencesManager.getString(\"string\", \"马云\"));Log.e(TAG, mSharePreferencesManager.remove(\"string\") + \"\");Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(\"hello1\");set.add(\"world1\");Log.e(TAG, mSharePreferencesManager.putStringSet(\"set\", set) + \"\");Log.e(TAG, mSharePreferencesManager.getStringSet(\"set\", null) + \"\");Log.e(TAG, \"map result &lt;&lt;\" + mSharePreferencesManager.getAll().toString()); 注意上面的步骤在任意进程都一样,并且数据都是安全共享的 问题使用过程中有任何问题反馈至feedback 支持 任何疑问? 源码学习safeSharedPreferences 贡献 clone项目发送pull request LicenseSafeSharedPreferences is under the Apache license. See the LICENSE file for details. 最近访客","tags":[{"name":"sharepreferences","slug":"sharepreferences","permalink":"http://www.jackway.cn/tags/sharepreferences/"},{"name":"contentprovider","slug":"contentprovider","permalink":"http://www.jackway.cn/tags/contentprovider/"},{"name":"martixcursor","slug":"martixcursor","permalink":"http://www.jackway.cn/tags/martixcursor/"}]},{"title":"单例模式真的很简单吗？","date":"2016-12-02T18:30:04.000Z","path":"2016/12/03/single/","text":"单例模式真的不简单，但是单例模式也是我们开发中常用的一种设计模式,然而不管Github上开源的代码，还是很多开发同学写的单例模式，百花齐放，百家争鸣，各种版本，这篇文章我想跟大家聊聊我心中的单例模式，同时我会给出我心目中的单例模式的各种版本，同时会给出不同版本的优缺点，以及我们最后应该选用哪个版本才是最为安全，优雅，同时性能也是比较好的，最后我想说，安全，性能是一个折中的考虑。 单例对象创建的一般步骤 构造函数private 定义static成员变量 提供static getInstance 方法获取对象 SingletonV1123456789101112131415public class SingletonV1 &#123; private static SingletonV1 sInstance; private SingletonV1() &#123; &#125; public static SingletonV1 getInstance() &#123; if (sInstance == null) &#123; sInstance = new SingletonV1(); &#125; return sInstance; &#125;&#125; 这个版本是最简单的方式创建单例对象,但是这个版本只适合单线程场景下，在并发条件下，不能保证对象为唯一性，如果有同学也这么实现的，赶紧反思一下。 SingletonV21234567891011121314public class SingletonV2 &#123; private static SingletonV2 sInstance; private SingletonV2() &#123; &#125; public static synchronized SingletonV2 getInstance() &#123; if (sInstance == null) &#123; sInstance = new SingletonV2(); &#125; return sInstance; &#125;&#125; 这个版本跟第一个版本的区别就是多了个synchronized关键字，暂且我们这么理解，这个关键字是保证保证线程安全的，这样一来，我们保证了单例，确实没错，但是这个版本并不是我想要的，为什么了？因为这个锁是方法锁，意味着性能损失较大，至于为什么损失较大，这里就不展开讲了，有疑问的同学可以评论里，向我提问。 SingletonV312345678910111213141516public class SingletonV3 &#123; private static SingletonV3 sInstance; private SingletonV3() &#123; &#125; public static SingletonV3 getInstance() &#123; synchronized (SingletonV3.class) &#123; if (sInstance == null) &#123; sInstance = new SingletonV3(); &#125; &#125; return sInstance; &#125;&#125; 这个版本看上去是代码段局部锁，但是我们仔细一看，其实跟第二个版本一模一样，没有本质区别，所以这个版本也不是我们想要的。 SingletonV4123456789101112131415161718public class SingletonV4 &#123; private static SingletonV4 sInstance; private SingletonV4() &#123; &#125; public static SingletonV4 getInstance() &#123; if (sInstance == null) &#123; synchronized (SingletonV4.class) &#123; if (sInstance == null) &#123; sInstance = new SingletonV4(); &#125; &#125; &#125; return sInstance; &#125;&#125; 这个版本最大的改进是在第三个版本的基础上实现了双层检测，在某种层度上，性能有所提升，但是是不是就没有安全问题了，不是的，这个版本也不是我们想要的，因为在指令重排的情况下，会出错，在这里也不打算展开讲为什么会出现这中诡异的现象，有想知道原因的，可以在评论里，向我提问。 SingletonV512345678910111213141516public class SingletonV5 &#123; private static SingletonV5 sInstance; private SingletonV5() &#123; &#125; public static SingletonV5 getInstance() &#123; if (sInstance == null) &#123; synchronized (SingletonV5.class) &#123; sInstance = new SingletonV5(); &#125; &#125; return sInstance; &#125;&#125; 这个版本有在并发的环境下很难保证单例，也有可能报错。 SingletonV612345678910111213141516171819202122public class SingletonV6 &#123; private static volatile SingletonV6 sInstance; private SingletonV6() &#123; &#125; protected Object readResolve() &#123; return getInstance(); &#125; public static SingletonV6 getInstance() &#123; if (sInstance == null) &#123; synchronized (SingletonV6.class) &#123; if (sInstance == null) &#123; sInstance = new SingletonV6(); &#125; &#125; &#125; return sInstance; &#125;&#125; 这个版本算比较完美了，在某种条件下，保证了单例，同时性能也有了一定的保证，同时反序列化也保证了单例，但是这种是不是也就没问题了，错了，这个版本在jdk1.5之后才能算完美，以前版本还是有问题的, 这里不展开讲原因，有疑问的同学在下面的评论，可以向我提问。 SingletonV7123public enum SingletonV7 &#123; INSTANCE&#125; 这个版本是上一个版本的增强版，同时也是最优雅的版本，也是最为安全的版本，性能也是较好的版本，同时基于自身特点保证了序列化，反序列化的安全，同时也是目前最为推荐使用的单例版本，这里不展开讲原因，有兴趣的同学，可以在下面的评论，向我提问。 SingletonV812345678910111213public class SingletonV8 &#123; private SingletonV8() &#123; &#125; private static class SingletonHolder &#123; private static final SingletonV8 INSTANCE = new SingletonV8(); &#125; public static SingletonV8 getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 这个版本也是虚拟机能够保证安全的版本，但是需要额外的内部类提供保证，空间复杂度比上面版本大，综合考虑还是考虑枚举版本 SingletonV91234567891011public class SingletonV9 &#123; private static final SingletonV9 INSTANCE = new SingletonV9(); private SingletonV9() &#123; &#125; public static SingletonV9 getInstance() &#123; return INSTANCE; &#125;&#125; 这个版本也是安全的，但是有个缺陷就是这个类只要其中有个静态成员加载，那么就会创建对象，也是我们经常说的饿汉式模式，上面的版本都是懒汉式模式，对于这两种模式不太了解的，可以在下面的评论，向我提问。 SingletonV1012345678910111213141516171819202122public class SingletonV10 &#123; private static volatile SingletonV10 sInstance; private static final AtomicBoolean FLAG = new AtomicBoolean(false); private SingletonV10() &#123; &#125; public static SingletonV10 getInstance() &#123; for (; ; ) &#123; if (FLAG.compareAndSet(false, true)) &#123; sInstance = new SingletonV10(); break; &#125; if (sInstance != null) &#123; break; &#125; &#125; return sInstance; &#125;&#125; 这个版本是用CAS的无阻塞，乐观锁的特性实现 SingletonV11123456789101112131415161718192021222324public class SingletonV11 &#123; private static volatile SingletonV11 sInstance; // over SingletonV11.class private static final Object LOCK = new Object(); private SingletonV11() &#123; &#125; protected Object readResolve() &#123; return getInstance(); &#125; public static SingletonV11 getInstance() &#123; if (sInstance == null) &#123; synchronized (LOCK) &#123; if (sInstance == null) &#123; sInstance = new SingletonV11(); &#125; &#125; &#125; return sInstance; &#125;&#125; 这个版本跟V6版本差不多，只是加锁用的对象不一样了，V6版本用的本身类Class对象，而这个版本用的静态对象Object 可能很多人都有疑问，这两种又啥区别了，其实还是不一样的，首先Class 这个就是磁盘文件映射到内存的一个副本对象，由虚拟机直接接管，那么肯定涉及到虚拟机对该对象的操作，如果虚拟的操作由于我们的加锁而被blocked那么性能会有影响，如果用static这种方式是不会用性能方面的影响的。 扩展 对象创建的不同方式，以及不同点 对象的创建过程 classloader的namespace 虚拟机实例的个数对对象的影响 继承对对象创建的影响 对象代码复用 对象锁，类锁，全局锁的区别 锁中的坑 这篇由于主要由浅入深的讲解单例，上面的扩展就不展开讲了，如果有感兴趣的同学，可以在评论里，向我提问，我会详细解答的，后面的文章我也会由浅入深的讲解。 总结看似很简单一种设计模式，其实我们深入思考一下，就没那么简单了，中间有很多技术点，有很多细节需要我们去挖掘，思考，最后推荐SingletonV7版本，注意这个只是保证了对象创建安全，对象成员的安全，还需要我们自己去保证。希望阅读过这篇文章的同学，再也不要写不安全的单例对象代码了，代码改进的一小步，程序稳定，可靠的一大步。 可能的疑问有的同学可能会在想，客户端平台不是不建议enum吗？确实没错，那是很早以前android官网也不建议使用，但是现在你去看官网还能看到那句话吗？google已经去掉了，至于为什么去掉了，我个人认为，有几种可能的原因，第一个是目前机器的配置，现在的cpu，内存等配置跟以前都不是在一个级别上，第二个就是软件层运行时对代码优化。另外还有JakeWharton大神都不考虑这个了，我们还有什么理由考虑这些了，其实真的没必要考虑这个了。 最近访客","tags":[{"name":"volatile","slug":"volatile","permalink":"http://www.jackway.cn/tags/volatile/"},{"name":"synchronized","slug":"synchronized","permalink":"http://www.jackway.cn/tags/synchronized/"},{"name":"single","slug":"single","permalink":"http://www.jackway.cn/tags/single/"},{"name":"enum","slug":"enum","permalink":"http://www.jackway.cn/tags/enum/"}]},{"title":"揭开Gradle的神秘面纱","date":"2016-11-28T16:32:01.000Z","path":"2016/11/29/gradle/","text":"gradle前言 在解开gradle神秘面纱前,我想说一下gradle是如此的强大,在我看来在目前互联网爆炸的时代,构建工具也不少,比如以前我接触的Ant,maven等,在这里只想说我接触gradle并且去研究之后,从此我就爱上了gradle的强大，灵活，高效，并且可以让我们android开发者上手快，这是因为我们android开发的主要语言是java，java是基于虚拟的一种语言，而gradle的最终产物也是java子节码，所以我认为我们写gadle代码就是写业务代码，当然也有不同，那就是dsl特性，后面会慢慢展开讲解，让大家真正的去理解gradle的强大，并且能够真正的在as的强大能力下，能够将gardle真正运用好，提高开发效率。这里我并不是吐槽其他构件工具不好,没有最好，只有更好，更适合，从客户端构件角度来看，我个人觉得gradle非常适合，下面将解开gradle一层一层的面纱。gradle大纲 gradle是什么 gradle的好处 gradle内部构建原理 如何使用gradle提高工作效率 gradle工程构建流 gradle实战 gradle是什么 gradle其实是一套构件工具机,使用groovy语言的DSL特性以及java的灵活特性进行构建,还有很多特性大家可以去gradle.org官网进行深入的学习或者google找相关资料了解 gradle的好处 其实我们学习一门技术肯定是有对应的好处我们才去学习对吧,不管好处多大,起码能帮助我们工作,毕竟我们都是上班的码农,我个人认为gradle最大的好处就是能够让我们更关注我们最关注的，不需要关注那些与我们关系不大的，毕竟我们不需要关注，然而这样就让我们失去了很多的深入学习的机会，导致我们养成了只要能用就行的思维，在我看来懒惰使人进步，为了想懒惰我一定要去思考如何自动化的去解决问题，gradle满足了我的目标，非常强大。 gradle的内部构建原理 在讲解内部构件原理之前，我想讲解下我是如何去理解gradle这玩意的，gradle按照一般写业务代码的思维还是有点区别的，毕竟领域不同，gradle写的是脚本，却运行的java子节码，所以我这么思考，我用写java运行时的思维去写gradle脚本，然后学习gradle dsl特性，这样以来，理解这个构建工具就非常流畅了，不然我是理解不好的，每个人都有自己的理解方式，找自己最好的理解方式就好。gradle构建内部运行机制是这样的，首先初始化构建引擎，然后将脚本转换成java代码,然后就是我们最熟悉的构建过程了,将java代码转换成子节码,然后交给虚拟机加载执行 如何使用gradle提高工作效率 我个人认为构建工具毕竟是一种工具特性,那么就一套完善的高效特性让我去挖掘,我目前挖掘的有利用as的工程特性，结合gradle的强大构建特性，自动化分析文件，自动化打包，模版构建，后面不断有新的挖掘，我相信只要是工具类的东西然后结合我们的技术手段那么肯定会提高我们的工作效率，可能需要手动10分钟的事情，而用gradle处理只要1分钟，甚至更短，错误几率也大大减低，减除人工干预，毕竟现在是人工智能时代，感觉我们会被计算机征服，真可怕，我们唯一能做的就是提升自己。 gradle工程构建流 as gradle工程构建流图示 gradle实战 构建脚本集 settings.gradle root build.gradle init.gradle utils.gradle tasks.gradle submodle build.gradle common.properties template/project.properties publish.bat/publish.sh properties gradle插件开发 插件开发基本流程 插件工程一般结构 插件开发语言(java,gradle,groovy等等) 插件打包 插件部署 插件访问 总结 到此gradle基本构建流已经说完了,这些只是构建的开始,后面我还会继续深入gradle在组件化开发中的作用以及强大支撑，只有明白了gradle的基本工作原理，我们才能更好的去灵活运用gradle来拆分我们的工程，很好的解耦我们的工程，目前比较的多的开发模式有组件化，插件化，我个人理解gradle就是开发模式的驱动者，学好gradle才是根本，才能很好的进行模式开发，gradle网上的指导资料很少，基本都是一些用法，没有分析原理的，对于技术者我强烈建议学习一门技术还是去对应的官网，这样不仅仅能系统的学习，并且还能更为深入的理解语言的本质。 建议 工程构建一般是跨界的，也就是说可能会涉及到很多种技术的融合，我目前接触到的有python，groovy，bash，bat 等脚本语言，希望大家不要仅仅停留在android业务开发中，技术融合才能让自己强大，多学习不同技术提高自己的维度，深度，广度。 后续gradle学习计划 继续深入gradle构建流 gradle源码分析 发现gradle中好玩的东西，灵活运用到实际项目中 基于gradle构建项目到产品输出闭环 gradle项目地址 下载 github查看 最近访客","tags":[{"name":"gradle","slug":"gradle","permalink":"http://www.jackway.cn/tags/gradle/"}]},{"title":"modularity","date":"2016-11-27T08:50:54.000Z","path":"2016/11/27/modularity/","text":"主题大纲 什么是组件化 什么是插件化 为什么要组件化 如何组件化 组件化的基本模型 组件化开发中的问题 组件化测试 组件化组件编译 组件化打包 组件化开发闭环链接系统 Q&amp;A 什么是组件化在了解组件化之前,我们首先回顾一下目前非组件化工程的基本结构,首先我想说大家最想说的是as编译太慢,编译让人蓝瘦香菇，并且谁者业务需求越来越多，代码越来越多，编译时间线性增加，有些同学可能会通过自己机器的配置对应的设置，as的编译配置文件，增量编译，但是这样的结果还不是很明显，一方面由于as对增量编译的支持力度，在这个过程中有代码缓存问题。我们通过clean去解决，这样会导致重新build，从而导致编译时间还是很长，编译就像as给予我们放松的时刻。面对上面的这些问题，我相信我们很多同学都思考过，拆分当个工程为多个工程，然后模块编译，模块测试，最后整合若干模块称为一个apk，没错，思路是对的，但是为什么这些理论很难得到实践了。这就是我们经常说的，理想很丰满，现实很骨感。当我们找到一个理论突破口的时候，就感觉很满足，就觉得就这样。我想说我们必须实践，熟话说，实践才是检验真理的唯一标准，我们需要思考，学习，实践，用理论去解决实际问题。我个人认为as与生俱来就是提供开发者模块化的ide，很多同学可能有疑问，为什么这么认为，我们开发时仅仅把as看作一个开发辅助工具，但是我们站在更高的角度去思考，其实as给我们不仅仅是一种工具，而是一种给予我们基于这个工具去能创造，创新开发模式的软件。明白了这些，那么组件化到底是什么了，我看目前网上关于组件化开发的文章，这说明也有很多在开发中实践的，我个人认为还是不够完善，或者说很多问题，很多坑。我对组件化的理解就是module化开发，module测试，module打包，module发包，module集成，module暴露，下面详细说这些具体怎么做。 什么是插件化有的同学很能有很大的疑问，主题是组件化，为什么要了解什么是插件化，这里只是说明一下插件化与组件化的区别，让我们实践过程中能够分清开发界限，能够将组件化做的更好。插件化是很多的开发模式，我们明白一点就可以了，插件化是单独的apk，jar，zip，dex，资源，so等。将这些进行动态加载，然而组件化本质还是一个主apk。不管多少module，最后都会整合成一个apk。所以我们就有了更新的开发模式，组件化中插件化，这里不详细展开说，今天主题是组件化，我们专一讲好一个主题，后面再安排讲解这种模式。 为什么要组件化一开始我们讲解了，什么组件化，以及组件化的好处，以及组件化的大致几个流程，有的同学可能还有很多的疑问，我们一个app运行起来，如果机器配置好点，速度也挺快的，写代码写起来也很舒服，组件化也没必要，可能还认为组件化开发流程复杂，带给我们的价值不大。我想说作为开发者千万不要这么想，我们要想的是这种模式能不能适合我们的场景，任何一种技术都是有场景范围的，不是universal的。我个人认为组件化最大的好处就是解耦合，最大程度的并行开发，非常适合自动化测试，非常适合代码管理，这些同学们不能很好的体会，后面我都会通过事例来讲解，先心中有个印象。 如何组件化 组件化开发要简单也可以很简单，要复杂也可以很复杂，但是我们开发就是要偷懒，要写脚本自动化执行我们重复的工作。所以我们如何将复杂的事情转化成简单的脚本，让as帮我们去加载执行。既然组件化是基于as的，那么首先我们需要学习gradle脚本的编写，groovy语言的学习，不同平台的脚本语言学习，比如mac下面的bash语言学习，还有一门辅助脚本的学习python，这些都可以让我们的组件化开发高效，从而提高开发效率，降低开发成本。没有做过组件化架构搭建的同学可能一下子就懵了，这些我都不要会，就会写基础代码，大多数都一样，不会我们学习就好，够用就好，然后不断去深入学习。有了这些基础的东西，下面进展就会比较顺利，不然后面可能很多问题。接下来我们就是需要拆分模块，同时引入基础库，初始化基本配置，配置依赖，这些后面我会通过演示的方式进行讲解。 组件化的基本模型基于我对组件化开发的实践，与团队对组件化的理解，我总结出了一套开发模型基本图 组件化开发中的问题其实组件化开发中很多问题需要我们解决，我遇到的有，依赖关系的处理，资源重复(通过添加资源前缀)，清单文件的冲突(tools)，打包运行崩溃，直接依赖aar,jar等 组件化测试由于业务需求多，我想同学们基本都是很少测试的，即使测试也是run一下，没有写单元测试，这很大原因是写测试代码需要发费很多时间，需要编译整个工程，编译时间太长。组件化之后，我们就很容易测试自己负责的module了，并不需要加载其他人写的module，目前我们可以用自测方式测试，不用自动化测试框架之内的，看个人对测试的兴趣，这部分我也会通过演示的方式，进行讲解,同时可能涉及到application访问的问题，即使在app容器里面也有类似的问题。 组件化组件编译组件化编译每个module都是一个aar，所以我们依赖直接aar就好，但是这里需要注意一个问题，就是必须依赖带有依赖文件的aar，比如pom文件，不管本地的还是服务端的，不然运行时可能出现Class找不到的情况。还有一些是生成jar包，直接依赖就好，如果组件化中有插件加载机制，需要注意插件工程依赖共同jar时重复打包问题，provider模式解决这种问题。 组件化打包组件化打包其实就是将aar进行整合，然后生成一个apk文件。这个apk可以单独加载，也可以单独运行。 组件化开发闭环链接系统组件化闭环系统基本组成:git源代码管理,maven二进制包管理,jenkins打包管理,gerrit代码审查等其他辅助系统，比如mail系统，短信系统。 Q&amp;A同学们的疑问与解答 最近访客","tags":[{"name":"modularity","slug":"modularity","permalink":"http://www.jackway.cn/tags/modularity/"}]}]